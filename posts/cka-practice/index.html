<!DOCTYPE html>
<html
  lang="en"
  dir="ltr"
  
><meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">


<title>CKA Simulator Kubernetes 1.23 | 云原生驿站</title>

<meta name="generator" content="Hugo Eureka 0.9.1" />
<link rel="stylesheet" href="/css/eureka.min.9cec6350e37e534b0338fa9a085bf06855de3b0f2dcf857e792e5e97b07ea905d4d5513db554cbc26a9c3da622bae92d.css" integrity="sha384-nOxjUON&#43;U0sDOPqaCFvwaFXeOw8tz4V&#43;eS5el7B&#43;qQXU1VE9tVTLwmqcPaYiuukt">
<script defer src="/js/eureka.min.f1639ee98d6cbd85b2b5f034d27320da962002ff83159ed4e01dbc5948c42a1ab26c2d6e74c66e93f5cec4d24dbd166d.js" integrity="sha384-8WOe6Y1svYWytfA00nMg2pYgAv&#43;DFZ7U4B28WUjEKhqybC1udMZuk/XOxNJNvRZt"></script>













<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&amp;family=Noto&#43;Serif&#43;SC:wght@400;600;700&amp;display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/highlight.min.js"
   crossorigin></script>
  <script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.4.0/build/languages/dart.min.js"
     crossorigin></script>
<link rel="stylesheet" href="/css/highlightjs.min.2958991528e43eb6fc9b8c4f2b8e052f79c4010718e1d1e888a777620e9ee63021c2c57ec7417a3108019bb8c41943e6.css" integrity="sha384-KViZFSjkPrb8m4xPK44FL3nEAQcY4dHoiKd3Yg6e5jAhwsV&#43;x0F6MQgBm7jEGUPm">


<script defer type="text/javascript" src="/js/fontawesome.min.556d8a720c2607066000ad1cb5cbdc4da8e61b339cf7b111c2cea521185d942db885a421557699c1c26cddd4ea8a76b2.js" integrity="sha384-VW2KcgwmBwZgAK0ctcvcTajmGzOc97ERws6lIRhdlC24haQhVXaZwcJs3dTqinay"></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"
   integrity="sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js" 
  integrity="sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
   integrity="sha384-&#43;XBljXPPiv&#43;OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>


<script defer src="https://cdn.jsdelivr.net/npm/mermaid@8.14.0/dist/mermaid.min.js" 
  integrity="sha384-atOyb0FxAgN9LyAc6PEf9BjgwLISyansgdH8/VXQH8p2o5vfrRgmGIJ2Sg22L0A0"  crossorigin></script>


<link rel="icon" type="image/png" sizes="32x32" href="/images/icon_hu3aa9085ba815027042fd0909df9ce115_24739_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/icon_hu3aa9085ba815027042fd0909df9ce115_24739_180x180_fill_box_center_3.png">

<meta name="description"
  content="killer shell 模拟题">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"文章",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"CKA Simulator Kubernetes 1.23",
      "item":"/posts/cka-practice/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/posts/cka-practice/"
    },
    "headline": "CKA Simulator Kubernetes 1.23 | 云原生驿站","datePublished": "2022-03-29T00:00:00+00:00",
    "dateModified": "2022-04-02T00:00:00+00:00",
    "wordCount":  11074 ,
    "author": {
        "@type": "Person",
        "name": ["云原生驿站"]
    },
    "publisher": {
        "@type": "Person",
        "name": "歪鼻子",
        "logo": {
            "@type": "ImageObject",
            "url": "/images/icon.png"
        }
        },
    "description": "killer shell 模拟题"
}
</script><meta property="og:title" content="CKA Simulator Kubernetes 1.23 | 云原生驿站" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/images/icon.png">


<meta property="og:url" content="/posts/cka-practice/" />



<meta property="og:description" content="killer shell 模拟题" />



<meta property="og:locale" content="en" />




<meta property="og:site_name" content="云原生驿站" />






<meta property="article:published_time" content="2022-03-29T00:00:00&#43;00:00" />


<meta property="article:modified_time" content="2022-04-02T00:00:00&#43;00:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="kubernetes" />














  <body class="flex min-h-screen flex-col">
    <header
      class="min-h-16 pl-scrollbar bg-secondary-bg fixed z-50 flex w-full items-center shadow-sm"
    >
      <div class="mx-auto w-full max-w-screen-xl"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if (((storageColorScheme == 'Auto' || storageColorScheme == null) && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap px-4 py-4 md:py-0">
    <a href="/" class="me-6 text-primary-text text-xl font-bold">云原生驿站</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="md:flex md:h-16 text-sm md:grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">关于</a>
            <a href="/posts/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  selected-menu-item  me-4">文章</a>
            <a href="/docs/" class="block mt-4 md:inline-block md:mt-0 md:h-(16-4px) md:leading-(16-4px) box-border md:border-t-2 md:border-b-2  border-transparent  me-4">文档</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-adjust"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col start-0 md:start-auto end-auto md:end-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka" name="Light">浅色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Dark">深色</span>
                    <span class="px-4 py-1 hover:text-eureka" name="Auto">自动</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == null || storageColorScheme == 'Auto') {
        document.addEventListener('DOMContentLoaded', () => {
            window.matchMedia("(prefers-color-scheme: dark)").addEventListener('change', switchDarkMode)
        })
    } else if (storageColorScheme == "Light") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'sun')
        element.firstElementChild.classList.add('fa-sun')
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-adjust')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }

    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script>
</div>
    </header>
    <main class="grow pt-16">
        <div class="pl-scrollbar">
          <div class="mx-auto w-full max-w-screen-xl lg:px-4 xl:px-8">
  
  
  <div class="grid grid-cols-2 gap-4 lg:grid-cols-8 lg:pt-12">
    <div
      class=" bg-secondary-bg col-span-2 rounded px-6 py-8 lg:col-span-6"
    >
      <article class="prose">
  <h1 class="mb-4">CKA Simulator Kubernetes 1.23</h1>

  <div
  class="text-tertiary-text not-prose mt-2 flex flex-row flex-wrap items-center"
>
  <div class="me-6 my-2">
    <i class="fas fa-calendar me-1"></i>
    <span
      >2022-03-29</span
    >
  </div>
  <div class="me-6 my-2">
    <i class="fas fa-clock me-1"></i>
    <span>52分钟阅读时长</span>
  </div>

  
    <div class="me-6 my-2">
      <i class="fas fa-folder me-1"></i>
      
        <a href="/categories/cka/" class="hover:text-eureka"
          >CKA</a
        >
      
        
          <span>, </span>
        <a href="/categories/kubernetes/" class="hover:text-eureka"
          >kubernetes</a
        >
      
    </div>
  

  
    <div class="me-6 my-2">
      <i class="fas fa-th-list me-1"></i>
      
        <a href="/series/kubernetes/" class="hover:text-eureka"
          >kubernetes</a
        >
      
    </div>
  
</div>


  
  

  <h4 id="pre-setup">Pre Setup</h4>
<p>Once you&rsquo;ve gained access to your terminal it might be wise to spend ~1 minute to setup your environment. You could set these:</p>
<pre><code class="language-shell">alias k=kubectl                         # will already be pre-configured

export do=&quot;--dry-run=client -o yaml&quot;    # k get pod x $do

export now=&quot;--force --grace-period 0&quot;   # k delete pod x $now
</code></pre>
<h5 id="vim">Vim</h5>
<p>To make <code>vim</code> use 2 spaces for a tab edit <code>~/.vimrc</code> to contain:</p>
<pre><code class="language-shell">set tabstop=2
set expandtab
set shiftwidth=2
</code></pre>
<p>More setup suggestions are in the <strong>tips section</strong>.</p>
<h2 id="question-1--contexts">Question 1 | Contexts</h2>
<p><em>Task weight: 1%</em></p>
<p>You have access to multiple clusters from your main terminal through <code>kubectl</code> contexts. Write all those context names into <code>/opt/course/1/contexts</code>.</p>
<p>Next write a command to display the current context into <code>/opt/course/1/context_default_kubectl.sh</code>, the command should use <code>kubectl</code>.</p>
<p>Finally write a second command doing the same thing into <code>/opt/course/1/context_default_no_kubectl.sh</code>, but without the use of <code>kubectl</code>.</p>
<h5 id="answer">Answer:</h5>
<p>Maybe the fastest way is just to run:</p>
<pre><code class="language-shell">k config get-contexts # copy manually

k config get-contexts -o name &gt; /opt/course/1/contexts
</code></pre>
<p>Or using jsonpath:</p>
<pre><code class="language-shell">k config view -o yaml # overview
k config view -o jsonpath=&quot;{.contexts[*].name}&quot;
k config view -o jsonpath=&quot;{.contexts[*].name}&quot; | tr &quot; &quot; &quot;\n&quot; # new lines
k config view -o jsonpath=&quot;{.contexts[*].name}&quot; | tr &quot; &quot; &quot;\n&quot; &gt; /opt/course/1/contexts 
</code></pre>
<p>The content should then look like:</p>
<pre><code class="language-shell"># /opt/course/1/contexts
k8s-c1-H
k8s-c2-AC
k8s-c3-CCC
</code></pre>
<p>Next create the first command:</p>
<pre><code class="language-shell"># /opt/course/1/context_default_kubectl.sh
kubectl config current-context
➜ sh /opt/course/1/context_default_kubectl.sh
k8s-c1-H
</code></pre>
<p>And the second one:</p>
<pre><code class="language-shell"># /opt/course/1/context_default_no_kubectl.sh
cat ~/.kube/config | grep current
➜ sh /opt/course/1/context_default_no_kubectl.sh
current-context: k8s-c1-H
</code></pre>
<p>In the real exam you might need to filter and find information from bigger lists of resources, hence knowing a little jsonpath and simple bash filtering will be helpful.</p>
<p>The second command could also be improved to:</p>
<pre><code class="language-shell"># /opt/course/1/context_default_no_kubectl.sh
cat ~/.kube/config | grep current | sed -e &quot;s/current-context: //&quot;
</code></pre>
<h2 id="question-2--schedule-pod-on-master-node">Question 2 | Schedule Pod on Master Node</h2>
<p><em>Task weight: 3%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Create a single <em>Pod</em> of image <code>httpd:2.4.41-alpine</code> in <em>Namespace</em> <code>default</code>. The <em>Pod</em> should be named <code>pod1</code> and the container should be named <code>pod1-container</code>. This <em>Pod</em> should <strong>only</strong> be scheduled on a master <em>node</em>, do not add new labels any nodes.</p>
<p>Shortly write the reason on why <em>Pods</em> are by default not scheduled on master nodes into <code>/opt/course/2/master_schedule_reason</code> .</p>
<h5 id="answer-1">Answer:</h5>
<p>First we find the master node(s) and their taints:</p>
<pre><code class="language-shell">k get node # find master node

k describe node cluster1-master1 | grep Taint # get master node taints

k describe node cluster1-master1 | grep Labels -A 10 # get master node labels

k get node cluster1-master1 --show-labels # OR: get master node labels
</code></pre>
<p>Next we create the <em>Pod</em> template:</p>
<pre><code class="language-shell"># check the export on the very top of this document so we can use $do
k run pod1 --image=httpd:2.4.41-alpine $do &gt; 2.yaml

vim 2.yaml
</code></pre>
<p>Perform the necessary changes manually. Use the Kubernetes docs and search for example for tolerations and nodeSelector to find examples:</p>
<pre><code class="language-yaml"># 2.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: pod1
  name: pod1
spec:
  containers:
  - image: httpd:2.4.41-alpine
    name: pod1-container                  # change
    resources: {}
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  tolerations:                            # add
  - effect: NoSchedule                    # add
    key: node-role.kubernetes.io/master   # add
  nodeSelector:                           # add
    node-role.kubernetes.io/master: &quot;&quot;    # add
status: {}
</code></pre>
<p>Important here to add the toleration for running on master nodes, but also the nodeSelector to make sure it only runs on master nodes. If we only specify a toleration the <em>Pod</em> can be scheduled on master or worker nodes.</p>
<p>Now we create it:</p>
<pre><code class="language-shell">k -f 2.yaml create
</code></pre>
<p>Let&rsquo;s check if the pod is scheduled:</p>
<pre><code class="language-shell">➜ k get pod pod1 -o wide
NAME   READY   STATUS    RESTARTS   ...    NODE               NOMINATED NODE
pod1   1/1     Running   0          ...    cluster1-master1   &lt;none&gt;        
</code></pre>
<p>Finally the short reason why <em>Pods</em> are not scheduled on master nodes by default:</p>
<pre><code class="language-shell"># /opt/course/2/master_schedule_reason
master nodes usually have a taint defined
</code></pre>
<h2 id="question-3--scale-down-statefulset">Question 3 | Scale down StatefulSet</h2>
<p><em>Task weight: 1%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>There are two <em>Pods</em> named <code>o3db-*</code> in <em>Namespace</em> <code>project-c13</code>. C13 management asked you to scale the <em>Pods</em> down to one replica to save resources. Record the action.</p>
<h5 id="answer-2">Answer:</h5>
<p>If we check the <em>Pods</em> we see two replicas:</p>
<pre><code class="language-shell">➜ k -n project-c13 get pod | grep o3db
o3db-0                                  1/1     Running   0          52s
o3db-1                                  1/1     Running   0          42s
</code></pre>
<p>From their name it looks like these are managed by a <em>StatefulSet</em>. But if we&rsquo;re not sure we could also check for the most common resources which manage <em>Pods</em>:</p>
<pre><code class="language-shell">➜ k -n project-c13 get deploy,ds,sts | grep o3db
statefulset.apps/o3db   2/2     2m56s
</code></pre>
<p>Confirmed, we have to work with a <em>StatefulSet</em>. To find this out we could also look at the <em>Pod</em> labels:</p>
<pre><code class="language-shell">➜ k -n project-c13 get pod --show-labels | grep o3db
o3db-0                                  1/1     Running   0          3m29s   app=nginx,controller-revision-hash=o3db-5fbd4bb9cc,statefulset.kubernetes.io/pod-name=o3db-0
o3db-1                                  1/1     Running   0          3m19s   app=nginx,controller-revision-hash=o3db-5fbd4bb9cc,statefulset.kubernetes.io/pod-name=o3db-1
</code></pre>
<p>To fulfil the task we simply run:</p>
<pre><code class="language-shell">➜ k -n project-c13 scale sts o3db --replicas 1 --record
statefulset.apps/o3db scaled

➜ k -n project-c13 get sts o3db
NAME   READY   AGE
o3db   1/1     4m39s
</code></pre>
<p>The <code>--record</code> created an annotation:</p>
<pre><code class="language-shell">➜ k -n project-c13 describe sts o3db
Name:               o3db
Namespace:          project-c13
CreationTimestamp:  Sun, 20 Sep 2020 14:47:57 +0000
Selector:           app=nginx
Labels:             &lt;none&gt;
Annotations:        kubernetes.io/change-cause: kubectl scale sts o3db --namespace=project-c13 --replicas=1 --record=true
Replicas:           1 desired | 1 total
</code></pre>
<p>C13 Mangement is happy again.</p>
<h2 id="question-4--pod-ready-if-service-is-reachable">Question 4 | Pod Ready if Service is reachable</h2>
<p><em>Task weight: 4%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Do the following in <em>Namespace</em> <code>default</code>. Create a single <em>Pod</em> named <code>ready-if-service-ready</code> of image <code>nginx:1.16.1-alpine</code>. Configure a LivenessProbe which simply runs <code>true</code>. Also configure a ReadinessProbe which does check if the url <code>http://service-am-i-ready:80</code> is reachable, you can use <code>wget -T2 -O- http://service-am-i-ready:80</code> for this. Start the <em>Pod</em> and confirm it isn&rsquo;t ready because of the ReadinessProbe.</p>
<p>Create a second <em>Pod</em> named <code>am-i-ready</code> of image <code>nginx:1.16.1-alpine</code> with label <code>id: cross-server-ready</code>. The already existing <em>Service</em> <code>service-am-i-ready</code> should now have that second <em>Pod</em> as endpoint.</p>
<p>Now the first <em>Pod</em> should be in ready state, confirm that.</p>
<h5 id="answer-3">Answer:</h5>
<p>It&rsquo;s a bit of an anti-pattern for one <em>Pod</em> to check another <em>Pod</em> for being ready using probes, hence the normally available <code>readinessProbe.httpGet</code> doesn&rsquo;t work for absolute remote urls. Still the workaround requested in this task should show how probes and <em>Pod</em>&lt;-&gt;<em>Service</em> communication works.</p>
<p>First we create the first <em>Pod</em>:</p>
<pre><code>k run ready-if-service-ready --image=nginx:1.16.1-alpine $do &gt; 4_pod1.yaml

vim 4_pod1.yaml
</code></pre>
<p>Next perform the necessary additions manually:</p>
<pre><code class="language-yaml"># 4_pod1.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: ready-if-service-ready
  name: ready-if-service-ready
spec:
  containers:
  - image: nginx:1.16.1-alpine
    name: ready-if-service-ready
    resources: {}
    livenessProbe:                               # add from here
      exec:
        command:
        - 'true'
    readinessProbe:
      exec:
        command:
        - sh
        - -c
        - 'wget -T2 -O- http://service-am-i-ready:80'   # to here
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
</code></pre>
<p>Then create the <em>Pod</em>:</p>
<pre><code class="language-shell">k -f 4_pod1.yaml create
</code></pre>
<p>And confirm its in a non-ready state:</p>
<pre><code class="language-shell">➜ k get pod ready-if-service-ready
NAME                     READY   STATUS    RESTARTS   AGE
ready-if-service-ready   0/1     Running   0          7s
</code></pre>
<p>We can also check the reason for this using describe:</p>
<pre><code class="language-shell">➜ k describe pod ready-if-service-ready
 ...
  Warning  Unhealthy  18s   kubelet, cluster1-worker1  Readiness probe failed: Connecting to service-am-i-ready:80 (10.109.194.234:80)
wget: download timed out
</code></pre>
<p>Now we create the second <em>Pod</em>:</p>
<pre><code class="language-shell">k run am-i-ready --image=nginx:1.16.1-alpine --labels=&quot;id=cross-server-ready&quot;
</code></pre>
<p>The already existing <em>Service</em> <code>service-am-i-ready</code> should now have an <em>Endpoint</em>:</p>
<pre><code class="language-shell">k describe svc service-am-i-ready
k get ep # also possible
</code></pre>
<p>Which will result in our first <em>Pod</em> being ready, just give it a minute for the Readiness probe to check again:</p>
<pre><code class="language-shell">➜ k get pod ready-if-service-ready
NAME                     READY   STATUS    RESTARTS   AGE
ready-if-service-ready   1/1     Running   0          53s
</code></pre>
<p>Look at these <em>Pods</em> coworking together!</p>
<h2 id="question-5--kubectl-sorting">Question 5 | Kubectl sorting</h2>
<p><em>Task weight: 1%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>There are various <em>Pods</em> in all namespaces. Write a command into <code>/opt/course/5/find_pods.sh</code> which lists all <em>Pods</em> sorted by their AGE (<code>metadata.creationTimestamp</code>).</p>
<p>Write a second command into <code>/opt/course/5/find_pods_uid.sh</code> which lists all <em>Pods</em> sorted by field <code>metadata.uid</code>. Use <code>kubectl</code> sorting for both commands.</p>
<h5 id="answer-4">Answer:</h5>
<p>A good resources here (and for many other things) is the kubectl-cheat-sheet. You can reach it fast when searching for &ldquo;cheat sheet&rdquo; in the Kubernetes docs.</p>
<pre><code class="language-shell"># /opt/course/5/find_pods.sh
kubectl get pod -A --sort-by=.metadata.creationTimestamp
</code></pre>
<p>And to execute:</p>
<pre><code class="language-shell">➜ sh /opt/course/5/find_pods.sh
NAMESPACE         NAME                                       ...          AGE
kube-system       kube-scheduler-cluster1-master1            ...          63m
kube-system       etcd-cluster1-master1                      ...          63m
kube-system       kube-apiserver-cluster1-master1            ...          63m
kube-system       kube-controller-manager-cluster1-master1   ...          63m
...
</code></pre>
<p>For the second command:</p>
<pre><code class="language-shell"># /opt/course/5/find_pods_uid.sh
kubectl get pod -A --sort-by=.metadata.uid
</code></pre>
<p>And to execute:</p>
<pre><code class="language-shell">➜ sh /opt/course/5/find_pods_uid.sh
NAMESPACE         NAME                                      ...          AGE
kube-system       coredns-5644d7b6d9-vwm7g                  ...          68m
project-c13       c13-3cc-runner-heavy-5486d76dd4-ddvlt     ...          63m
project-hamster   web-hamster-shop-849966f479-278vp         ...          63m
project-c13       c13-3cc-web-646b6c8756-qsg4b              ...          63m
</code></pre>
<h2 id="question-6--storage-pv-pvc-pod-volume">Question 6 | Storage, PV, PVC, Pod volume</h2>
<p><em>Task weight: 8%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Create a new <em>PersistentVolume</em> named <code>safari-pv</code>. It should have a capacity of <em>2Gi</em>, accessMode <em>ReadWriteOnce</em>, hostPath <code>/Volumes/Data</code> and no storageClassName defined.</p>
<p>Next create a new <em>PersistentVolumeClaim</em> in <em>Namespace</em> <code>project-tiger</code> named <code>safari-pvc</code> . It should request <em>2Gi</em> storage, accessMode <em>ReadWriteOnce</em> and should not define a storageClassName. The <em>PVC</em> should bound to the <em>PV</em> correctly.</p>
<p>Finally create a new <em>Deployment</em> <code>safari</code> in <em>Namespace</em> <code>project-tiger</code> which mounts that volume at <code>/tmp/safari-data</code>. The <em>Pods</em> of that <em>Deployment</em> should be of image <code>httpd:2.4.41-alpine</code>.</p>
<h5 id="answer-5">Answer</h5>
<pre><code class="language-shell">vim 6_pv.yaml
</code></pre>
<p>Find an example from <a href="https://kubernetes.io/docs">https://kubernetes.io/docs</a> and alter it:</p>
<pre><code class="language-yaml"># 6_pv.yaml
kind: PersistentVolume
apiVersion: v1
metadata:
 name: safari-pv
spec:
 capacity:
  storage: 2Gi
 accessModes:
  - ReadWriteOnce
 hostPath:
  path: &quot;/Volumes/Data&quot;
</code></pre>
<p>Then create it:</p>
<pre><code class="language-shell">k -f 6_pv.yaml create
</code></pre>
<p>Next the <em>PersistentVolumeClaim</em>:</p>
<pre><code class="language-shell">vim 6_pvc.yaml
</code></pre>
<p>Find an example from <a href="https://kubernetes.io/docs">https://kubernetes.io/docs</a> and alter it:</p>
<pre><code class="language-yaml"># 6_pvc.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: safari-pvc
  namespace: project-tiger
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
     storage: 2Gi
</code></pre>
<p>Then create:</p>
<pre><code class="language-shell">k -f 6_pvc.yaml create
</code></pre>
<p>And check that both have the status Bound:</p>
<pre><code class="language-shell">➜ k -n project-tiger get pv,pvc
NAME                         CAPACITY  ... STATUS   CLAIM                    ...
persistentvolume/safari-pv   2Gi       ... Bound    project-tiger/safari-pvc ...

NAME                               STATUS   VOLUME      CAPACITY ...
persistentvolumeclaim/safari-pvc   Bound    safari-pv   2Gi      ...
</code></pre>
<p>Next we create a <em>Deployment</em> and mount that volume:</p>
<pre><code class="language-shell">k -n project-tiger create deploy safari \
  --image=httpd:2.4.41-alpine $do &gt; 6_dep.yaml

vim 6_dep.yaml
</code></pre>
<p>Alter the yaml to mount the volume:</p>
<pre><code class="language-yaml"># 6_dep.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: safari
  name: safari
  namespace: project-tiger
spec:
  replicas: 1
  selector:
    matchLabels:
      app: safari
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        app: safari
    spec:
      volumes:                                      # add
      - name: data                                  # add
        persistentVolumeClaim:                      # add
          claimName: safari-pvc                     # add
      containers:
      - image: httpd:2.4.41-alpine
        name: container
        volumeMounts:                               # add
        - name: data                                # add
          mountPath: /tmp/safari-data               # add
k -f 6_dep.yaml create
</code></pre>
<p>We can confirm its mounting correctly:</p>
<pre><code class="language-shell">➜ k -n project-tiger describe pod safari-5cbf46d6d-mjhsb  | grep -A2 Mounts:   
    Mounts:
      /tmp/safari-data from data (rw) # there it is
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-n2sjj (ro)
</code></pre>
<h2 id="question-7--node-and-pod-resource-usage">Question 7 | Node and Pod Resource Usage</h2>
<p><em>Task weight: 1%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>The metrics-server hasn&rsquo;t been installed yet in the cluster, but it&rsquo;s something that should be done soon. Your college would already like to know the kubectl commands to:</p>
<ol>
<li>show <em>node</em> resource usage</li>
<li>show <em>Pod</em> and their containers resource usage</li>
</ol>
<p>Please write the commands into <code>/opt/course/7/node.sh</code> and <code>/opt/course/7/pod.sh</code>.</p>
<h5 id="answer-6">Answer:</h5>
<p>The command we need to use here is top:</p>
<pre><code class="language-shell">➜ k top -h
Display Resource (CPU/Memory/Storage) usage.

 The top command allows you to see the resource consumption for nodes or pods.

 This command requires Metrics Server to be correctly configured and working on the server.

Available Commands:
  node        Display Resource (CPU/Memory/Storage) usage of nodes
  pod         Display Resource (CPU/Memory/Storage) usage of pods
</code></pre>
<p>We see that the metrics server is not configured yet:</p>
<pre><code class="language-shell">➜ k top node
error: Metrics API not available
</code></pre>
<p>But we trust the kubectl documentation and create the first file:</p>
<pre><code class="language-shell"># /opt/course/7/node.sh
kubectl top node
</code></pre>
<p>For the second file we might need to check the docs again:</p>
<pre><code class="language-shell">➜ k top pod -h
Display Resource (CPU/Memory/Storage) usage of pods.
...
Namespace in current context is ignored even if specified with --namespace.
      --containers=false: If present, print usage of containers within a pod.
      --no-headers=false: If present, print output without headers.
...
</code></pre>
<p>With this we can finish this task:</p>
<pre><code class="language-shell"># /opt/course/7/pod.sh
kubectl top pod --containers=true
</code></pre>
<h2 id="question-8--get-master-information">Question 8 | Get Master Information</h2>
<p><em>Task weight: 2%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Ssh into the master node with <code>ssh cluster1-master1</code>. Check how the master components kubelet, kube-apiserver, kube-scheduler, kube-controller-manager and etcd are started/installed on the master node. Also find out the name of the DNS application and how it&rsquo;s started/installed on the master node.</p>
<p>Write your findings into file <code>/opt/course/8/master-components.txt</code>. The file should be structured like:</p>
<pre><code class="language-tex"># /opt/course/8/master-components.txt
kubelet: [TYPE]
kube-apiserver: [TYPE]
kube-scheduler: [TYPE]
kube-controller-manager: [TYPE]
etcd: [TYPE]
dns: [TYPE] [NAME]
</code></pre>
<p>Choices of <code>[TYPE]</code> are: <code>not-installed</code>, <code>process</code>, <code>static-pod</code>, <code>pod</code></p>
<h5 id="answer-7">Answer:</h5>
<p>We could start by finding processes of the requested components, especially the kubelet at first:</p>
<pre><code class="language-shell">➜ ssh cluster1-master1

root@cluster1-master1:~# ps aux | grep kubelet # shows kubelet process
</code></pre>
<p>We can see which components are controlled via systemd looking at <code>/etc/systemd/system</code> directory:</p>
<pre><code class="language-shell">➜ root@cluster1-master1:~# find /etc/systemd/system/ | grep kube
/etc/systemd/system/kubelet.service.d
/etc/systemd/system/kubelet.service.d/10-kubeadm.conf
/etc/systemd/system/multi-user.target.wants/kubelet.service

➜ root@cluster1-master1:~# find /etc/systemd/system/ | grep etcd
</code></pre>
<p>This shows kubelet is controlled via systemd, but no other service named kube nor etcd. It seems that this cluster has been setup using kubeadm, so we check in the default manifests directory:</p>
<pre><code class="language-shell">➜ root@cluster1-master1:~# find /etc/kubernetes/manifests/
/etc/kubernetes/manifests/
/etc/kubernetes/manifests/kube-controller-manager.yaml
/etc/kubernetes/manifests/etcd.yaml
/etc/kubernetes/manifests/kube-scheduler-special.yaml
/etc/kubernetes/manifests/kube-apiserver.yaml
/etc/kubernetes/manifests/kube-scheduler.yaml
</code></pre>
<p>(The kubelet could also have a different manifests directory specified via parameter <code>--pod-manifest-path</code> in it&rsquo;s systemd startup config)</p>
<p>This means the main 4 master services are setup as static <em>Pods</em>. There also seems to be a second scheduler <code>kube-scheduler-special</code> existing.</p>
<p>Actually, let&rsquo;s check all <em>Pods</em> running on in the <code>kube-system</code> <em>Namespace</em> on the master node:</p>
<pre><code class="language-shell">➜ root@cluster1-master1:~# kubectl -n kube-system get pod -o wide | grep master1
coredns-5644d7b6d9-c4f68                   1/1     Running            ...   cluster1-master1
coredns-5644d7b6d9-t84sc                   1/1     Running            ...   cluster1-master1
etcd-cluster1-master1                      1/1     Running            ...   cluster1-master1
kube-apiserver-cluster1-master1            1/1     Running            ...   cluster1-master1
kube-controller-manager-cluster1-master1   1/1     Running            ...   cluster1-master1
kube-proxy-q955p                           1/1     Running            ...   cluster1-master1
kube-scheduler-cluster1-master1            1/1     Running            ...   cluster1-master1
kube-scheduler-special-cluster1-master1    0/1     CrashLoopBackOff   ...   cluster1-master1
weave-net-mwj47                            2/2     Running            ...   cluster1-master1
</code></pre>
<p>There we see the 5 static pods, with <code>-cluster1-master1</code> as suffix.</p>
<p>We also see that the dns application seems to be coredns, but how is it controlled?</p>
<pre><code class="language-shell">➜ root@cluster1-master1$ kubectl -n kube-system get ds
NAME         DESIRED   CURRENT   ...   NODE SELECTOR            AGE
kube-proxy   3         3         ...   kubernetes.io/os=linux   155m
weave-net    3         3         ...   &lt;none&gt;                   155m

➜ root@cluster1-master1$ kubectl -n kube-system get deploy
NAME      READY   UP-TO-DATE   AVAILABLE   AGE
coredns   2/2     2            2           155m
</code></pre>
<p>Seems like coredns is controlled via a <em>Deployment</em>. We combine our findings in the requested file:</p>
<pre><code class="language-shell"># /opt/course/8/master-components.txt
kubelet: process
kube-apiserver: static-pod
kube-scheduler: static-pod
kube-scheduler-special: static-pod (status CrashLoopBackOff)
kube-controller-manager: static-pod
etcd: static-pod
dns: pod coredns
</code></pre>
<p>You should be comfortable investigating a running cluster, know different methods on how a cluster and its services can be setup and be able to troubleshoot and find error sources.</p>
<h2 id="question-9--kill-scheduler-manual-scheduling">Question 9 | Kill Scheduler, Manual Scheduling</h2>
<p><em>Task weight: 5%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c2-AC</code></p>
<p>Ssh into the master node with <code>ssh cluster2-master1</code>. <strong>Temporarily</strong> stop the kube-scheduler, this means in a way that you can start it again afterwards.</p>
<p>Create a single <em>Pod</em> named <code>manual-schedule</code> of image <code>httpd:2.4-alpine</code>, confirm its created but not scheduled on any node.</p>
<p>Now you&rsquo;re the scheduler and have all its power, manually schedule that <em>Pod</em> on node cluster2-master1. Make sure it&rsquo;s running.</p>
<p>Start the kube-scheduler again and confirm its running correctly by creating a second <em>Pod</em> named <code>manual-schedule2</code> of image <code>httpd:2.4-alpine</code> and check if it&rsquo;s running on cluster2-worker1.</p>
<h5 id="answer-8">Answer:</h5>
<h6 id="stop-the-scheduler">Stop the Scheduler</h6>
<p>First we find the master node:</p>
<pre><code class="language-shell">➜ k get node
NAME               STATUS   ROLES    AGE   VERSION
cluster2-master1   Ready    master   26h   v1.23.1
cluster2-worker1   Ready    &lt;none&gt;   26h   v1.23.1
</code></pre>
<p>Then we connect and check if the scheduler is running:</p>
<pre><code class="language-shell">➜ ssh cluster2-master1

➜ root@cluster2-master1:~# kubectl -n kube-system get pod | grep schedule
kube-scheduler-cluster2-master1            1/1     Running   0          6s
</code></pre>
<p>Kill the Scheduler (temporarily):</p>
<pre><code class="language-shell">➜ root@cluster2-master1:~# cd /etc/kubernetes/manifests/

➜ root@cluster2-master1:~# mv kube-scheduler.yaml ..
</code></pre>
<p>And it should be stopped:</p>
<pre><code class="language-shell">➜ root@cluster2-master1:~# kubectl -n kube-system get pod | grep schedule

➜ root@cluster2-master1:~# 
</code></pre>
<h6 id="create-a-pod">Create a <em>Pod</em></h6>
<p>Now we create the <em>Pod</em>:</p>
<pre><code class="language-shell">k run manual-schedule --image=httpd:2.4-alpine
</code></pre>
<p>And confirm it has no node assigned:</p>
<pre><code class="language-shell">➜ k get pod manual-schedule -o wide
NAME              READY   STATUS    ...   NODE     NOMINATED NODE
manual-schedule   0/1     Pending   ...   &lt;none&gt;   &lt;none&gt;        
</code></pre>
<h6 id="manually-schedule-the-pod">Manually schedule the <em>Pod</em></h6>
<p>Let&rsquo;s play the scheduler now:</p>
<pre><code class="language-yaml">k get pod manual-schedule -o yaml &gt; 9.yaml
# 9.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: &quot;2020-09-04T15:51:02Z&quot;
  labels:
    run: manual-schedule
  managedFields:
...
    manager: kubectl-run
    operation: Update
    time: &quot;2020-09-04T15:51:02Z&quot;
  name: manual-schedule
  namespace: default
  resourceVersion: &quot;3515&quot;
  selfLink: /api/v1/namespaces/default/pods/manual-schedule
  uid: 8e9d2532-4779-4e63-b5af-feb82c74a935
spec:
  nodeName: cluster2-master1        # add the master node name
  containers:
  - image: httpd:2.4-alpine
    imagePullPolicy: IfNotPresent
    name: manual-schedule
    resources: {}
    terminationMessagePath: /dev/termination-log
    terminationMessagePolicy: File
    volumeMounts:
    - mountPath: /var/run/secrets/kubernetes.io/serviceaccount
      name: default-token-nxnc7
      readOnly: true
  dnsPolicy: ClusterFirst
...

</code></pre>
<p>The only thing a scheduler does, is that it sets the nodeName for a <em>Pod</em> declaration. How it finds the correct node to schedule on, that&rsquo;s a very much complicated matter and takes many variables into account.</p>
<p>As we cannot <code>kubectl apply</code> or <code>kubectl edit</code> , in this case we need to delete and create or replace:</p>
<pre><code class="language-shell">k -f 9.yaml replace --force
</code></pre>
<p>How does it look?</p>
<pre><code class="language-shell">➜ k get pod manual-schedule -o wide
NAME              READY   STATUS    ...   NODE            
manual-schedule   1/1     Running   ...   cluster2-master1
</code></pre>
<p>It looks like our <em>Pod</em> is running on the master now as requested, although no tolerations were specified. Only the scheduler takes tains/tolerations/affinity into account when finding the correct node name. That&rsquo;s why its still possible to assign <em>Pods</em> manually directly to a master node and skip the scheduler.</p>
<h6 id="start-the-scheduler-again">Start the scheduler again</h6>
<pre><code class="language-shell">➜ ssh cluster2-master1

➜ root@cluster2-master1:~# cd /etc/kubernetes/manifests/

➜ root@cluster2-master1:~# mv ../kube-scheduler.yaml .
</code></pre>
<p>Checks its running:</p>
<pre><code class="language-shell">➜ root@cluster2-master1:~# kubectl -n kube-system get pod | grep schedule
kube-scheduler-cluster2-master1            1/1     Running   0          16s
</code></pre>
<p>Schedule a second test <em>Pod</em>:</p>
<pre><code class="language-shell">k run manual-schedule2 --image=httpd:2.4-alpine
➜ k get pod -o wide | grep schedule
manual-schedule    1/1     Running   ...   cluster2-master1
manual-schedule2   1/1     Running   ...   cluster2-worker1
</code></pre>
<p>Back to normal.</p>
<h2 id="question-10--rbac-serviceaccount-role-rolebinding">Question 10 | RBAC ServiceAccount Role RoleBinding</h2>
<p><em>Task weight: 6%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Create a new <em>ServiceAccount</em> <code>processor</code> in <em>Namespace</em> <code>project-hamster</code>. Create a <em>Role</em> and <em>RoleBinding</em>, both named <code>processor</code> as well. These should allow the new <em>SA</em> to only create <em>Secrets</em> and <em>ConfigMaps</em> in that <em>Namespace</em>.</p>
<h5 id="answer-9">Answer:</h5>
<h6 id="lets-talk-a-little-about-rbac-resources">Let&rsquo;s talk a little about RBAC resources</h6>
<p>A <em>ClusterRole</em>|<em>Role</em> defines a set of permissions and <strong>where it is available</strong>, in the whole cluster or just a single <em>Namespace</em>.</p>
<p>A <em>ClusterRoleBinding</em>|<em>RoleBinding</em> connects a set of permissions with an account and defines <strong>where it is applied</strong>, in the whole cluster or just a single <em>Namespace</em>.</p>
<p>Because of this there are 4 different RBAC combinations and 3 valid ones:</p>
<ol>
<li><em>Role</em> + <em>RoleBinding</em> (available in single <em>Namespace</em>, applied in single <em>Namespace</em>)</li>
<li><em>ClusterRole</em> + <em>ClusterRoleBinding</em> (available cluster-wide, applied cluster-wide)</li>
<li><em>ClusterRole</em> + <em>RoleBinding</em> (available cluster-wide, applied in single <em>Namespace</em>)</li>
<li><em>Role</em> + <em>ClusterRoleBinding</em> (<strong>NOT POSSIBLE:</strong> available in single <em>Namespace</em>, applied cluster-wide)</li>
</ol>
<h6 id="to-the-solution">To the solution</h6>
<p>We first create the <em>ServiceAccount</em>:</p>
<pre><code class="language-shell">➜ k -n project-hamster create sa processor
serviceaccount/processor created
</code></pre>
<p>Then for the <em>Role</em>:</p>
<pre><code class="language-shell">k -n project-hamster create role -h # examples
</code></pre>
<p>So we execute:</p>
<pre><code class="language-shell">k -n project-hamster create role processor \
  --verb=create \
  --resource=secret \
  --resource=configmap
</code></pre>
<p>Which will create a <em>Role</em> like:</p>
<pre><code class="language-shell"># kubectl -n project-hamster create role accessor --verb=create --resource=secret --resource=configmap
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: processor
  namespace: project-hamster
rules:
- apiGroups:
  - &quot;&quot;
  resources:
  - secrets
  - configmaps
  verbs:
  - create
</code></pre>
<p>Now we bind the <em>Role</em> to the <em>ServiceAccount</em>:</p>
<pre><code class="language-shell">k -n project-hamster create rolebinding -h # examples
</code></pre>
<p>So we create it:</p>
<pre><code class="language-shell">k -n project-hamster create rolebinding processor \
  --role processor \
  --serviceaccount project-hamster:processor
</code></pre>
<p>This will create a <em>RoleBinding</em> like:</p>
<pre><code class="language-yaml"># kubectl -n project-hamster create rolebinding processor --role processor --serviceaccount project-hamster:processor
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: processor
  namespace: project-hamster
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: processor
subjects:
- kind: ServiceAccount
  name: processor
  namespace: project-hamster
</code></pre>
<p>To test our RBAC setup we can use <code>kubectl auth can-i</code>:</p>
<pre><code class="language-shell">k auth can-i -h # examples
</code></pre>
<p>Like this:</p>
<pre><code class="language-shell">➜ k -n project-hamster auth can-i create secret \
  --as system:serviceaccount:project-hamster:processor
yes

➜ k -n project-hamster auth can-i create configmap \
  --as system:serviceaccount:project-hamster:processor
yes

➜ k -n project-hamster auth can-i create pod \
  --as system:serviceaccount:project-hamster:processor
no

➜ k -n project-hamster auth can-i delete secret \
  --as system:serviceaccount:project-hamster:processor
no

➜ k -n project-hamster auth can-i get configmap \
  --as system:serviceaccount:project-hamster:processor
no
</code></pre>
<p>Done.</p>
<h2 id="question-11--daemonset-on-all-nodes">Question 11 | DaemonSet on all Nodes</h2>
<p><em>Task weight: 4%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Use <em>Namespace</em> <code>project-tiger</code> for the following. Create a <em>DaemonSet</em> named <code>ds-important</code> with image <code>httpd:2.4-alpine</code> and labels <code>id=ds-important</code> and <code>uuid=18426a0b-5f59-4e10-923f-c0e078e82462</code>. The <em>Pods</em> it creates should request 10 millicore cpu and 10 mebibyte memory. The <em>Pods</em> of that <em>DaemonSet</em> should run on all nodes, master and worker.</p>
<h5 id="answer-10">Answer:</h5>
<p>As of now we aren&rsquo;t able to create a <em>DaemonSet</em> directly using <code>kubectl</code>, so we create a <em>Deployment</em> and just change it up:</p>
<pre><code class="language-shell">k -n project-tiger create deployment --image=httpd:2.4-alpine ds-important $do &gt; 11.yaml

vim 11.yaml
</code></pre>
<p>(Sure you could also search for a <em>DaemonSet</em> example yaml in the Kubernetes docs and alter it.)</p>
<p>Then we adjust the yaml to:</p>
<pre><code class="language-yaml"># 11.yaml
apiVersion: apps/v1
kind: DaemonSet                                     # change from Deployment to Daemonset
metadata:
  creationTimestamp: null
  labels:                                           # add
    id: ds-important                                # add
    uuid: 18426a0b-5f59-4e10-923f-c0e078e82462      # add
  name: ds-important
  namespace: project-tiger                          # important
spec:
  #replicas: 1                                      # remove
  selector:
    matchLabels:
      id: ds-important                              # add
      uuid: 18426a0b-5f59-4e10-923f-c0e078e82462    # add
  #strategy: {}                                     # remove
  template:
    metadata:
      creationTimestamp: null
      labels:
        id: ds-important                            # add
        uuid: 18426a0b-5f59-4e10-923f-c0e078e82462  # add
    spec:
      containers:
      - image: httpd:2.4-alpine
        name: ds-important
        resources:
          requests:                                 # add
            cpu: 10m                                # add
            memory: 10Mi                            # add
      tolerations:                                  # add
      - effect: NoSchedule                          # add
        key: node-role.kubernetes.io/master         # add
#status: {}                                         # remove
</code></pre>
<p>It was requested that the <em>DaemonSet</em> runs on all nodes, so we need to specify the toleration for this.</p>
<p>Let&rsquo;s confirm:</p>
<pre><code class="language-shell">k -f 11.yaml create
➜ k -n project-tiger get ds
NAME           DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
ds-important   3         3         3       3            3           &lt;none&gt;          8s
➜ k -n project-tiger get pod -l id=ds-important -o wide
NAME                      READY   STATUS          NODE
ds-important-6pvgm        1/1     Running   ...   cluster1-worker1
ds-important-lh5ts        1/1     Running   ...   cluster1-master1
ds-important-qhjcq        1/1     Running   ...   cluster1-worker2
</code></pre>
<h2 id="question-12--deployment-on-all-nodes">Question 12 | Deployment on all Nodes</h2>
<p><em>Task weight: 6%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Use <em>Namespace</em> <code>project-tiger</code> for the following. Create a <em>Deployment</em> named <code>deploy-important</code> with label <code>id=very-important</code> (the <code>Pods</code> should also have this label) and 3 replicas. It should contain two containers, the first named <code>container1</code> with image <code>nginx:1.17.6-alpine</code> and the second one named container2 with image <code>kubernetes/pause</code>.</p>
<p>There should be only ever <strong>one</strong> <em>Pod</em> of that <em>Deployment</em> running on <strong>one</strong> worker node. We have two worker nodes: <code>cluster1-worker1</code> and <code>cluster1-worker2</code>. Because the <em>Deployment</em> has three replicas the result should be that on both nodes <strong>one</strong> <em>Pod</em> is running. The third <em>Pod</em> won&rsquo;t be scheduled, unless a new worker node will be added.</p>
<p>In a way we kind of simulate the behaviour of a <em>DaemonSet</em> here, but using a <em>Deployment</em> and a fixed number of replicas.</p>
<h5 id="answer-11">Answer:</h5>
<p>There are two possible ways, one using <code>podAntiAffinity</code> and one using <code>topologySpreadConstraint</code>.</p>
<h6 id="podantiaffinity">PodAntiAffinity</h6>
<p>The idea here is that we create a &ldquo;Inter-pod anti-affinity&rdquo; which allows us to say a <em>Pod</em> should only be scheduled on a node where another <em>Pod</em> of a specific label (here the same label) is not already running.</p>
<p>Let&rsquo;s begin by creating the <em>Deployment</em> template:</p>
<pre><code class="language-shell">k -n project-tiger create deployment \
  --image=nginx:1.17.6-alpine deploy-important $do &gt; 12.yaml

vim 12.yaml
</code></pre>
<p>Then change the yaml to:</p>
<pre><code class="language-yaml"># 12.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    id: very-important                  # change
  name: deploy-important
  namespace: project-tiger              # important
spec:
  replicas: 3                           # change
  selector:
    matchLabels:
      id: very-important                # change
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        id: very-important              # change
    spec:
      containers:
      - image: nginx:1.17.6-alpine
        name: container1                # change
        resources: {}
      - image: kubernetes/pause         # add
        name: container2                # add
      affinity:                                             # add
        podAntiAffinity:                                    # add
          requiredDuringSchedulingIgnoredDuringExecution:   # add
          - labelSelector:                                  # add
              matchExpressions:                             # add
              - key: id                                     # add
                operator: In                                # add
                values:                                     # add
                - very-important                            # add
            topologyKey: kubernetes.io/hostname             # add
status: {}
</code></pre>
<p>Specify a topologyKey, which is a pre-populated Kubernetes label, you can find this by describing a node.</p>
<h6 id="topologyspreadconstraints">TopologySpreadConstraints</h6>
<p>We can achieve the same with <code>topologySpreadConstraints</code>. Best to try out and play with both.</p>
<pre><code class="language-yaml"># 12.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    id: very-important                  # change
  name: deploy-important
  namespace: project-tiger              # important
spec:
  replicas: 3                           # change
  selector:
    matchLabels:
      id: very-important                # change
  strategy: {}
  template:
    metadata:
      creationTimestamp: null
      labels:
        id: very-important              # change
    spec:
      containers:
      - image: nginx:1.17.6-alpine
        name: container1                # change
        resources: {}
      - image: kubernetes/pause         # add
        name: container2                # add
      topologySpreadConstraints:                 # add
      - maxSkew: 1                               # add
        topologyKey: kubernetes.io/hostname      # add
        whenUnsatisfiable: DoNotSchedule         # add
        labelSelector:                           # add
          matchLabels:                           # add
            id: very-important                   # add
status: {}
</code></pre>
<h6 id="apply-and-run">Apply and Run</h6>
<p>Let&rsquo;s run it:</p>
<pre><code class="language-shell">k -f 12.yaml create
</code></pre>
<p>Then we check the <em>Deployment</em> status where it shows 2/3 ready count:</p>
<pre><code class="language-shell">➜ k -n project-tiger get deploy -l id=very-important
NAME               READY   UP-TO-DATE   AVAILABLE   AGE
deploy-important   2/3     3            2           2m35s
</code></pre>
<p>And running the following we see one <em>Pod</em> on each worker node and one not scheduled.</p>
<pre><code class="language-shell">➜ k -n project-tiger get pod -o wide -l id=very-important
NAME                                READY   STATUS    ...   NODE             
deploy-important-58db9db6fc-9ljpw   2/2     Running   ...   cluster1-worker1
deploy-important-58db9db6fc-lnxdb   0/2     Pending   ...   &lt;none&gt;          
deploy-important-58db9db6fc-p2rz8   2/2     Running   ...   cluster1-worker2
</code></pre>
<p>If we kubectl describe the <em>Pod</em> <code>deploy-important-58db9db6fc-lnxdb</code> it will show us the reason for not scheduling is our implemented podAntiAffinity ruling:</p>
<pre><code class="language-shell">Warning  FailedScheduling  63s (x3 over 65s)  default-scheduler  0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't tolerate, 2 node(s) didn't match pod affinity/anti-affinity, 2 node(s) didn't satisfy existing pods anti-affinity rules.
</code></pre>
<p>Or our topologySpreadConstraints:</p>
<pre><code class="language-shell">Warning  FailedScheduling  16s   default-scheduler  0/3 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't tolerate, 2 node(s) didn't match pod topology spread constraints.
</code></pre>
<h2 id="question-13--multi-containers-and-pod-shared-volume">Question 13 | Multi Containers and Pod shared Volume</h2>
<p><em>Task weight: 4%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Create a <em>Pod</em> named <code>multi-container-playground</code> in <em>Namespace</em> <code>default</code> with three containers, named <code>c1</code>, <code>c2</code> and <code>c3</code>. There should be a volume attached to that <em>Pod</em> and mounted into every container, but the volume shouldn&rsquo;t be persisted or shared with other <em>Pods</em>.</p>
<p>Container <code>c1</code> should be of image <code>nginx:1.17.6-alpine</code> and have the name of the node where its <em>Pod</em> is running available as environment variable MY_NODE_NAME.</p>
<p>Container <code>c2</code> should be of image <code>busybox:1.31.1</code> and write the output of the <code>date</code> command every second in the shared volume into file <code>date.log</code>. You can use <code>while true; do date &gt;&gt; /your/vol/path/date.log; sleep 1; done</code> for this.</p>
<p>Container <code>c3</code> should be of image <code>busybox:1.31.1</code> and constantly send the content of file <code>date.log</code> from the shared volume to stdout. You can use <code>tail -f /your/vol/path/date.log</code> for this.</p>
<p>Check the logs of container <code>c3</code> to confirm correct setup.</p>
<h5 id="answer-12">Answer:</h5>
<p>First we create the <em>Pod</em> template:</p>
<pre><code class="language-shell">k run multi-container-playground --image=nginx:1.17.6-alpine $do &gt; 13.yaml

vim 13.yaml
</code></pre>
<p>And add the other containers and the commands they should execute:</p>
<pre><code class="language-shell"># 13.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: multi-container-playground
  name: multi-container-playground
spec:
  containers:
  - image: nginx:1.17.6-alpine
    name: c1                                                                      # change
    resources: {}
    env:                                                                          # add
    - name: MY_NODE_NAME                                                          # add
      valueFrom:                                                                  # add
        fieldRef:                                                                 # add
          fieldPath: spec.nodeName                                                # add
    volumeMounts:                                                                 # add
    - name: vol                                                                   # add
      mountPath: /vol                                                             # add
  - image: busybox:1.31.1                                                         # add
    name: c2                                                                      # add
    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;while true; do date &gt;&gt; /vol/date.log; sleep 1; done&quot;]  # add
    volumeMounts:                                                                 # add
    - name: vol                                                                   # add
      mountPath: /vol                                                             # add
  - image: busybox:1.31.1                                                         # add
    name: c3                                                                      # add
    command: [&quot;sh&quot;, &quot;-c&quot;, &quot;tail -f /vol/date.log&quot;]                                # add
    volumeMounts:                                                                 # add
    - name: vol                                                                   # add
      mountPath: /vol                                                             # add
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  volumes:                                                                        # add
    - name: vol                                                                   # add
      emptyDir: {}                                                                # add
status: {}
k -f 13.yaml create
</code></pre>
<p>Oh boy, lot&rsquo;s of requested things. We check if everything is good with the <em>Pod</em>:</p>
<pre><code class="language-shell">➜ k get pod multi-container-playground
NAME                         READY   STATUS    RESTARTS   AGE
multi-container-playground   3/3     Running   0          95s
</code></pre>
<p>Good, then we check if container c1 has the requested node name as env variable:</p>
<pre><code class="language-shell">➜ k exec multi-container-playground -c c1 -- env | grep MY
MY_NODE_NAME=cluster1-worker2
</code></pre>
<p>And finally we check the logging:</p>
<pre><code class="language-shell">➜ k logs multi-container-playground -c c3
Sat Dec  7 16:05:10 UTC 2077
Sat Dec  7 16:05:11 UTC 2077
Sat Dec  7 16:05:12 UTC 2077
Sat Dec  7 16:05:13 UTC 2077
Sat Dec  7 16:05:14 UTC 2077
Sat Dec  7 16:05:15 UTC 2077
Sat Dec  7 16:05:16 UTC 2077
</code></pre>
<h2 id="question-14--find-out-cluster-information">Question 14 | Find out Cluster Information</h2>
<p><em>Task weight: 2%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>You&rsquo;re ask to find out following information about the cluster <code>k8s-c1-H</code>:</p>
<ol>
<li>How many master nodes are available?</li>
<li>How many worker nodes are available?</li>
<li>What is the Service CIDR?</li>
<li>Which Networking (or CNI Plugin) is configured and where is its config file?</li>
<li>Which suffix will static pods have that run on cluster1-worker1?</li>
</ol>
<p>Write your answers into file <code>/opt/course/14/cluster-info</code>, structured like this:</p>
<pre><code class="language-shell"># /opt/course/14/cluster-info
1: [ANSWER]
2: [ANSWER]
3: [ANSWER]
4: [ANSWER]
5: [ANSWER]
</code></pre>
<h5 id="answer-13">Answer:</h5>
<h6 id="how-many-master-and-worker-nodes-are-available">How many master and worker nodes are available?</h6>
<pre><code class="language-shell">➜ k get node
NAME               STATUS   ROLES    AGE   VERSION
cluster1-master1   Ready    master   27h   v1.23.1
cluster1-worker1   Ready    &lt;none&gt;   27h   v1.23.1
cluster1-worker2   Ready    &lt;none&gt;   27h   v1.23.1
</code></pre>
<p>We see one master and two workers.</p>
<h6 id="what-is-the-service-cidr">What is the Service CIDR?</h6>
<pre><code class="language-shell">➜ ssh cluster1-master1

➜ root@cluster1-master1:~# cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep range
    - --service-cluster-ip-range=10.96.0.0/12
</code></pre>
<h6 id="which-networking-or-cni-plugin-is-configured-and-where-is-its-config-file">Which Networking (or CNI Plugin) is configured and where is its config file?</h6>
<pre><code class="language-shell">➜ root@cluster1-master1:~# find /etc/cni/net.d/
/etc/cni/net.d/
/etc/cni/net.d/10-weave.conflist

➜ root@cluster1-master1:~# cat /etc/cni/net.d/10-weave.conflist
{
    &quot;cniVersion&quot;: &quot;0.3.0&quot;,
    &quot;name&quot;: &quot;weave&quot;,
...
</code></pre>
<p>By default the kubelet looks into <code>/etc/cni/net.d</code> to discover the CNI plugins. This will be the same on every master and worker nodes.</p>
<h6 id="which-suffix-will-static-pods-have-that-run-on-cluster1-worker1">Which suffix will static pods have that run on cluster1-worker1?</h6>
<p>The suffix is the node hostname with a leading hyphen. It used to be <code>-static</code> in earlier Kubernetes versions.</p>
<h6 id="result">Result</h6>
<p>The resulting <code>/opt/course/14/cluster-info</code> could look like:</p>
<pre><code class="language-shell"># /opt/course/14/cluster-info

# How many master nodes are available?
1: 1

# How many worker nodes are available?
2: 2

# What is the Service CIDR?
3: 10.96.0.0/12

# Which Networking (or CNI Plugin) is configured and where is its config file?
4: Weave, /etc/cni/net.d/10-weave.conflist

# Which suffix will static pods have that run on cluster1-worker1?
5: -cluster1-worker1
</code></pre>
<h2 id="question-15--cluster-event-logging">Question 15 | Cluster Event Logging</h2>
<p><em>Task weight: 3%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c2-AC</code></p>
<p>Write a command into <code>/opt/course/15/cluster_events.sh</code> which shows the latest events in the whole cluster, ordered by time. Use <code>kubectl</code> for it.</p>
<p>Now kill the kube-proxy <em>Pod</em> running on node cluster2-worker1 and write the events this caused into <code>/opt/course/15/pod_kill.log</code>.</p>
<p>Finally kill the containerd container of the kube-proxy <em>Pod</em> on node cluster2-worker1 and write the events into <code>/opt/course/15/container_kill.log</code>.</p>
<p>Do you notice differences in the events both actions caused?</p>
<h5 id="answer-14">Answer:</h5>
<pre><code class="language-shell"># /opt/course/15/cluster_events.sh
kubectl get events -A --sort-by=.metadata.creationTimestamp
</code></pre>
<p>Now we kill the kube-proxy <em>Pod</em>:</p>
<pre><code class="language-shell">k -n kube-system get pod -o wide | grep proxy # find pod running on cluster2-worker1

k -n kube-system delete pod kube-proxy-z64cg
</code></pre>
<p>Now check the events:</p>
<pre><code class="language-shell">sh /opt/course/15/cluster_events.sh
</code></pre>
<p>Write the events the killing caused into <code>/opt/course/15/pod_kill.log</code>:</p>
<pre><code class="language-shell"># /opt/course/15/pod_kill.log
kube-system   9s          Normal    Killing           pod/kube-proxy-jsv7t   ...
kube-system   3s          Normal    SuccessfulCreate  daemonset/kube-proxy   ...
kube-system   &lt;unknown&gt;   Normal    Scheduled         pod/kube-proxy-m52sx   ...
default       2s          Normal    Starting          node/cluster2-worker1  ...
kube-system   2s          Normal    Created           pod/kube-proxy-m52sx   ...
kube-system   2s          Normal    Pulled            pod/kube-proxy-m52sx   ...
kube-system   2s          Normal    Started           pod/kube-proxy-m52sx   ...
</code></pre>
<p>Finally we will try to provoke events by killing the container belonging to the container of the kube-proxy <em>Pod</em>:</p>
<pre><code class="language-shell">➜ ssh cluster2-worker1

➜ root@cluster2-worker1:~# crictl ps | grep kube-proxy
1e020b43c4423   36c4ebbc9d979   About an hour ago   Running   kube-proxy     ...

➜ root@cluster2-worker1:~# crictl rm 1e020b43c4423
1e020b43c4423

➜ root@cluster2-worker1:~# crictl ps | grep kube-proxy
0ae4245707910   36c4ebbc9d979   17 seconds ago      Running   kube-proxy     ...     
</code></pre>
<p>We killed the main container (1e020b43c4423), but also noticed that a new container (0ae4245707910) was directly created. Thanks Kubernetes!</p>
<p>Now we see if this caused events again and we write those into the second file:</p>
<pre><code class="language-shell">sh /opt/course/15/cluster_events.sh
# /opt/course/15/container_kill.log
kube-system   13s         Normal    Created      pod/kube-proxy-m52sx    ...
kube-system   13s         Normal    Pulled       pod/kube-proxy-m52sx    ...
kube-system   13s         Normal    Started      pod/kube-proxy-m52sx    ...
</code></pre>
<p>Comparing the events we see that when we deleted the whole <em>Pod</em> there were more things to be done, hence more events. For example was the <em>DaemonSet</em> in the game to re-create the missing <em>Pod</em>. Where when we manually killed the main container of the <em>Pod</em>, the <em>Pod</em> would still exist but only its container needed to be re-created, hence less events.</p>
<h2 id="question-16--namespaces-and-api-resources">Question 16 | Namespaces and Api Resources</h2>
<p><em>Task weight: 2%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>Create a new <em>Namespace</em> called <code>cka-master</code>.</p>
<p>Write the names of all namespaced Kubernetes resources (like <em>Pod</em>, <em>Secret</em>, <em>ConfigMap</em>&hellip;) into <code>/opt/course/16/resources.txt</code>.</p>
<p>Find the <code>project-*</code> <em>Namespace</em> with the highest number of <code>Roles</code> defined in it and write its name and amount of <em>Roles</em> into <code>/opt/course/16/crowded-namespace.txt</code>.</p>
<h5 id="answer-15">Answer:</h5>
<h6 id="namespace-and-namespaces-resources">Namespace and Namespaces Resources</h6>
<p>We create a new <em>Namespace</em>:</p>
<pre><code class="language-shell">k create ns cka-master
</code></pre>
<p>Now we can get a list of all resources like:</p>
<pre><code class="language-shell">k api-resources    # shows all

k api-resources -h # help always good

k api-resources --namespaced -o name &gt; /opt/course/16/resources.txt
</code></pre>
<p>Which results in the file:</p>
<pre><code class="language-shell"># /opt/course/16/resources.txt
bindings
configmaps
endpoints
events
limitranges
persistentvolumeclaims
pods
podtemplates
replicationcontrollers
resourcequotas
secrets
serviceaccounts
services
controllerrevisions.apps
daemonsets.apps
deployments.apps
replicasets.apps
statefulsets.apps
localsubjectaccessreviews.authorization.k8s.io
horizontalpodautoscalers.autoscaling
cronjobs.batch
jobs.batch
leases.coordination.k8s.io
events.events.k8s.io
ingresses.extensions
ingresses.networking.k8s.io
networkpolicies.networking.k8s.io
poddisruptionbudgets.policy
rolebindings.rbac.authorization.k8s.io
roles.rbac.authorization.k8s.io
</code></pre>
<h6 id="namespace-with-most-roles">Namespace with most Roles</h6>
<pre><code class="language-shell">➜ k -n project-c13 get role --no-headers | wc -l
No resources found in project-c13 namespace.
0

➜ k -n project-c14 get role --no-headers | wc -l
300

➜ k -n project-hamster get role --no-headers | wc -l
No resources found in project-hamster namespace.
0

➜ k -n project-snake get role --no-headers | wc -l
No resources found in project-snake namespace.
0

➜ k -n project-tiger get role --no-headers | wc -l
No resources found in project-tiger namespace.
0
</code></pre>
<p>Finally we write the name and amount into the file:</p>
<pre><code class="language-shell"># /opt/course/16/crowded-namespace.txt
project-c14 with 300 resources
</code></pre>
<h2 id="question-17--find-container-of-pod-and-check-info">Question 17 | Find Container of Pod and check info</h2>
<p><em>Task weight: 3%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>In <em>Namespace</em> <code>project-tiger</code> create a <em>Pod</em> named <code>tigers-reunite</code> of image <code>httpd:2.4.41-alpine</code> with labels <code>pod=container</code> and <code>container=pod</code>. Find out on which node the <em>Pod</em> is scheduled. Ssh into that node and find the containerd container belonging to that <em>Pod</em>.</p>
<p>Using command <code>crictl</code>:</p>
<ol>
<li>Write the ID of the container and the <code>info.runtimeType</code> into <code>/opt/course/17/pod-container.txt</code></li>
<li>Write the logs of the container into <code>/opt/course/17/pod-container.log</code></li>
</ol>
<h5 id="answer-16">Answer:</h5>
<p>First we create the <em>Pod</em>:</p>
<pre><code class="language-shell">k -n project-tiger run tigers-reunite \
  --image=httpd:2.4.41-alpine \
  --labels &quot;pod=container,container=pod&quot;
</code></pre>
<p>Next we find out the node it&rsquo;s scheduled on:</p>
<pre><code class="language-shell">k -n project-tiger get pod -o wide

# or fancy:
k -n project-tiger get pod tigers-reunite -o jsonpath=&quot;{.spec.nodeName}&quot;
</code></pre>
<p>Then we ssh into that node and and check the container info:</p>
<pre><code class="language-shell">➜ ssh cluster1-worker2

➜ root@cluster1-worker2:~# crictl ps | grep tigers-reunite
b01edbe6f89ed    54b0995a63052    5 seconds ago    Running        tigers-reunite ...

➜ root@cluster1-worker2:~# crictl inspect b01edbe6f89ed | grep runtimeType
    &quot;runtimeType&quot;: &quot;io.containerd.runc.v2&quot;,
</code></pre>
<p>Then we fill the requested file (on the main terminal):</p>
<pre><code class="language-shell"># /opt/course/17/pod-container.txt
b01edbe6f89ed io.containerd.runc.v2
</code></pre>
<p>Finally we write the container logs in the second file:</p>
<pre><code class="language-shell">ssh cluster1-worker2 'crictl logs b01edbe6f89ed' &amp;&gt; /opt/course/17/pod-container.log
</code></pre>
<p>The <code>&amp;&gt;</code> in above&rsquo;s command redirects both the standard output and standard error.</p>
<p>You could also simply run <code>crictl logs</code> on the node and copy the content manually, if its not a lot. The file should look like:</p>
<pre><code class="language-tex"># /opt/course/17/pod-container.log
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.44.0.37. Set the 'ServerName' directive globally to suppress this message
AH00558: httpd: Could not reliably determine the server's fully qualified domain name, using 10.44.0.37. Set the 'ServerName' directive globally to suppress this message
[Mon Sep 13 13:32:18.555280 2021] [mpm_event:notice] [pid 1:tid 139929534545224] AH00489: Apache/2.4.41 (Unix) configured -- resuming normal operations
[Mon Sep 13 13:32:18.555610 2021] [core:notice] [pid 1:tid 139929534545224] AH00094: Command line: 'httpd -D FOREGROUND'
</code></pre>
<h2 id="question-18--fix-kubelet">Question 18 | Fix Kubelet</h2>
<p><em>Task weight: 8%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c3-CCC</code></p>
<p>There seems to be an issue with the kubelet not running on <code>cluster3-worker1</code>. Fix it and confirm that cluster has node <code>cluster3-worker1</code> available in Ready state afterwards. You should be able to schedule a <em>Pod</em> on <code>cluster3-worker1</code> afterwards.</p>
<p>Write the reason of the issue into <code>/opt/course/18/reason.txt</code>.</p>
<h5 id="answer-17">Answer:</h5>
<p>The procedure on tasks like these should be to check if the kubelet is running, if not start it, then check its logs and correct errors if there are some.</p>
<p>Always helpful to check if other clusters already have some of the components defined and running, so you can copy and use existing config files. Though in this case it might not need to be necessary.</p>
<p>Check node status:</p>
<pre><code class="language-shell">➜ k get node
NAME               STATUS     ROLES    AGE   VERSION
cluster3-master1   Ready      master   27h   v1.23.1
cluster3-worker1   NotReady   &lt;none&gt;   26h   v1.23.1
</code></pre>
<p>First we check if the kubelet is running:</p>
<pre><code class="language-shell">➜ ssh cluster3-worker1

➜ root@cluster3-worker1:~# ps aux | grep kubelet
root     29294  0.0  0.2  14856  1016 pts/0    S+   11:30   0:00 grep --color=auto kubelet
</code></pre>
<p>Nope, so we check if its configured using systemd as service:</p>
<pre><code class="language-shell">➜ root@cluster3-worker1:~# service kubelet status
● kubelet.service - kubelet: The Kubernetes Node Agent
   Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)
  Drop-In: /etc/systemd/system/kubelet.service.d
           └─10-kubeadm.conf
   Active: inactive (dead) since Sun 2019-12-08 11:30:06 UTC; 50min 52s ago
...
</code></pre>
<p>Yes, its configured as a service with config at <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>, but we see its inactive. Let&rsquo;s try to start it:</p>
<pre><code class="language-shell">➜ root@cluster3-worker1:~# service kubelet start

➜ root@cluster3-worker1:~# service kubelet status
● kubelet.service - kubelet: The Kubernetes Node Agent
   Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)
  Drop-In: /etc/systemd/system/kubelet.service.d
           └─10-kubeadm.conf
   Active: activating (auto-restart) (Result: exit-code) since Thu 2020-04-30 22:03:10 UTC; 3s ago
     Docs: https://kubernetes.io/docs/home/
  Process: 5989 ExecStart=/usr/local/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=203/EXEC)
 Main PID: 5989 (code=exited, status=203/EXEC)

Apr 30 22:03:10 cluster3-worker1 systemd[5989]: kubelet.service: Failed at step EXEC spawning /usr/local/bin/kubelet: No such file or directory
Apr 30 22:03:10 cluster3-worker1 systemd[1]: kubelet.service: Main process exited, code=exited, status=203/EXEC
Apr 30 22:03:10 cluster3-worker1 systemd[1]: kubelet.service: Failed with result 'exit-code'.
</code></pre>
<p>We see its trying to execute <code>/usr/local/bin/kubelet</code> with some parameters defined in its service config file. A good way to find errors and get more logs is to run the command manually (usually also with its parameters).</p>
<pre><code class="language-shell">➜ root@cluster3-worker1:~# /usr/local/bin/kubelet
-bash: /usr/local/bin/kubelet: No such file or directory

➜ root@cluster3-worker1:~# whereis kubelet
kubelet: /usr/bin/kubelet
</code></pre>
<p>Another way would be to see the extended logging of a service like using <code>journalctl -u kubelet</code>.</p>
<p><strong>Well, there we have it, wrong path specified. Correct the path in file</strong> <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code> and run:</p>
<pre><code class="language-shell">vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf # fix

systemctl daemon-reload &amp;&amp; systemctl restart kubelet

systemctl status kubelet  # should now show running
</code></pre>
<p>Also the node should be available for the api server, <strong>give it a bit of time though</strong>:</p>
<pre><code class="language-shell">➜ k get node
NAME               STATUS   ROLES    AGE   VERSION
cluster3-master1   Ready    master   27h   v1.23.1
cluster3-worker1   Ready    &lt;none&gt;   27h   v1.23.1
</code></pre>
<p>Finally we write the reason into the file:</p>
<pre><code class="language-shell"># /opt/course/18/reason.txt
wrong path to kubelet binary specified in service config
</code></pre>
<h2 id="question-19--create-secret-and-mount-into-pod">Question 19 | Create Secret and mount into Pod</h2>
<p><em>Task weight: 3%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c3-CCC</code></p>
<p>Do the following in a new <em>Namespace</em> <code>secret</code>. Create a <em>Pod</em> named <code>secret-pod</code> of image <code>busybox:1.31.1</code> which should keep running for some time. It should be able to run on master nodes as well, create the proper toleration.</p>
<p>There is an existing <em>Secret</em> located at <code>/opt/course/19/secret1.yaml</code>, create it in the <code>secret</code> <em>Namespace</em> and mount it readonly into the <em>Pod</em> at <code>/tmp/secret1</code>.</p>
<p>Create a new <em>Secret</em> in <em>Namespace</em> <code>secret</code> called <code>secret2</code> which should contain <code>user=user1</code> and <code>pass=1234</code>. These entries should be available inside the <em>Pod&rsquo;s</em> container as environment variables APP_USER and APP_PASS.</p>
<p>Confirm everything is working.</p>
<h5 id="answer-18">Answer</h5>
<p>First we create the <em>Namespace</em> and the requested <em>Secrets</em> in it:</p>
<pre><code class="language-shell">k create ns secret

cp /opt/course/19/secret1.yaml 19_secret1.yaml

vim 19_secret1.yaml
</code></pre>
<p>We need to adjust the <em>Namespace</em> for that <em>Secret</em>:</p>
<pre><code class="language-shell"># 19_secret1.yaml
apiVersion: v1
data:
  halt: IyEgL2Jpbi9zaAo...
kind: Secret
metadata:
  creationTimestamp: null
  name: secret1
  namespace: secret           # change
k -f 19_secret1.yaml create
</code></pre>
<p>Next we create the second <em>Secret</em>:</p>
<pre><code class="language-shell">k -n secret create secret generic secret2 --from-literal=user=user1 --from-literal=pass=1234
</code></pre>
<p>Now we create the <em>Pod</em> template:</p>
<pre><code class="language-shell">k -n secret run secret-pod --image=busybox:1.31.1 $do -- sh -c &quot;sleep 5d&quot; &gt; 19.yaml

vim 19.yaml
</code></pre>
<p>Then make the necessary changes:</p>
<pre><code class="language-yaml"># 19.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: secret-pod
  name: secret-pod
  namespace: secret                       # add
spec:
  tolerations:                            # add
  - effect: NoSchedule                    # add
    key: node-role.kubernetes.io/master   # add
  containers:
  - args:
    - sh
    - -c
    - sleep 1d
    image: busybox:1.31.1
    name: secret-pod
    resources: {}
    env:                                  # add
    - name: APP_USER                      # add
      valueFrom:                          # add
        secretKeyRef:                     # add
          name: secret2                   # add
          key: user                       # add
    - name: APP_PASS                      # add
      valueFrom:                          # add
        secretKeyRef:                     # add
          name: secret2                   # add
          key: pass                       # add
    volumeMounts:                         # add
    - name: secret1                       # add
      mountPath: /tmp/secret1             # add
      readOnly: true                      # add
  dnsPolicy: ClusterFirst
  restartPolicy: Always
  volumes:                                # add
  - name: secret1                         # add
    secret:                               # add
      secretName: secret1                 # add
status: {}
</code></pre>
<p>It might not be necessary in current K8s versions to specify the <code>readOnly: true</code> because it&rsquo;s the <a href="https://github.com/kubernetes/kubernetes/issues/62099">default setting anyways</a>.</p>
<p>And execute:</p>
<pre><code class="language-shell">k -f 19.yaml create
</code></pre>
<p>Finally we check if all is correct:</p>
<pre><code class="language-shell">➜ k -n secret exec secret-pod -- env | grep APP
APP_PASS=1234
APP_USER=user1
➜ k -n secret exec secret-pod -- find /tmp/secret1
/tmp/secret1
/tmp/secret1/..data
/tmp/secret1/halt
/tmp/secret1/..2019_12_08_12_15_39.463036797
/tmp/secret1/..2019_12_08_12_15_39.463036797/halt
➜ k -n secret exec secret-pod -- cat /tmp/secret1/halt
#! /bin/sh
### BEGIN INIT INFO
# Provides:          halt
# Required-Start:
# Required-Stop:
# Default-Start:
# Default-Stop:      0
# Short-Description: Execute the halt command.
# Description:
...
</code></pre>
<p>All is good.</p>
<h2 id="question-20--update-kubernetes-version-and-join-cluster">Question 20 | Update Kubernetes Version and join cluster</h2>
<p><em>Task weight: 10%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c3-CCC</code></p>
<p>Your coworker said node <code>cluster3-worker2</code> is running an older Kubernetes version and is not even part of the cluster. Update Kubernetes on that node to the exact version that&rsquo;s running on <code>cluster3-master1</code>. Then add this node to the cluster. Use kubeadm for this.</p>
<h5 id="answer-19">Answer:</h5>
<h6 id="upgrade-kubernetes-to-cluster3-master1-version">Upgrade Kubernetes to cluster3-master1 version</h6>
<p>Search in the docs for kubeadm upgrade: <a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade">https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade</a></p>
<pre><code class="language-shell">➜ k get node
NAME               STATUS     ROLES                  AGE    VERSION
cluster3-master1   Ready      control-plane,master   116m   v1.23.1
cluster3-worker1   NotReady   &lt;none&gt;                 112m   v1.23.1
</code></pre>
<p>Master node seems to be running Kubernetes 1.23.1 and <code>cluster3-worker2</code> is not yet part of the cluster.</p>
<pre><code class="language-shell">➜ ssh cluster3-worker2

➜ root@cluster3-worker2:~# kubeadm version
kubeadm version: &amp;version.Info{Major:&quot;1&quot;, Minor:&quot;23&quot;, GitVersion:&quot;v1.23.1&quot;, GitCommit:&quot;86ec240af8cbd1b60bcc4c03c20da9b98005b92e&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2021-12-16T11:39:51Z&quot;, GoVersion:&quot;go1.17.5&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}

➜ root@cluster3-worker2:~# kubectl version
Client Version: version.Info{Major:&quot;1&quot;, Minor:&quot;22&quot;, GitVersion:&quot;v1.22.4&quot;, GitCommit:&quot;b695d79d4f967c403a96986f1750a35eb75e75f1&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2021-11-17T15:48:33Z&quot;, GoVersion:&quot;go1.16.10&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;}
The connection to the server localhost:8080 was refused - did you specify the right host or port?

➜ root@cluster3-worker2:~# kubelet --version
Kubernetes v1.22.4
</code></pre>
<p>Here kubeadm is already installed in the wanted version, so we can run:</p>
<pre><code class="language-shell">➜ root@cluster3-worker2:~# kubeadm upgrade node
couldn't create a Kubernetes client from file &quot;/etc/kubernetes/kubelet.conf&quot;: failed to load admin kubeconfig: open /etc/kubernetes/kubelet.conf: no such file or directory
To see the stack trace of this error execute with --v=5 or higher
</code></pre>
<p>This is usually the proper command to upgrade a node. But this error means that this node was never even initialised, so nothing to update here. This will be done later using <code>kubeadm join</code>. For now we can continue with kubelet and kubectl:</p>
<pre><code class="language-shell">➜ root@cluster3-worker2:~# apt update
...
Fetched 5,775 kB in 2s (2,313 kB/s)                               
Reading package lists... Done
Building dependency tree       
Reading state information... Done
90 packages can be upgraded. Run 'apt list --upgradable' to see them.

➜ root@cluster3-worker2:~# apt show kubectl -a | grep 1.23
WARNING: apt does not have a stable CLI interface. Use with caution in scripts.
Version: 1.23.1-00
Version: 1.23.0-00

➜ root@cluster3-worker2:~# apt install kubectl=1.23.1-00 kubelet=1.23.1-00
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following packages will be upgraded:
  kubectl kubelet
2 upgraded, 0 newly installed, 0 to remove and 88 not upgraded.
Need to get 28.4 MB of archives.
After this operation, 2,976 kB of additional disk space will be used.
Get:1 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 kubectl amd64 1.23.1-00 [8,928 kB]
Get:2 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 kubelet amd64 1.23.1-00 [19.5 MB]
Fetched 28.4 MB in 2s (17.9 MB/s)  
(Reading database ... 111951 files and directories currently installed.)
Preparing to unpack .../kubectl_1.23.1-00_amd64.deb ...
Unpacking kubectl (1.23.1-00) over (1.22.4-00) ...
Preparing to unpack .../kubelet_1.23.1-00_amd64.deb ...
Unpacking kubelet (1.23.1-00) over (1.22.4-00) ...
Setting up kubectl (1.23.1-00) ...
Setting up kubelet (1.23.1-00) ...

➜ root@cluster3-worker2:~# kubelet --version
Kubernetes v1.23.1
</code></pre>
<p>Now we&rsquo;re up to date with kubeadm, kubectl and kubelet. Restart the kubelet:</p>
<pre><code class="language-shell">➜ root@cluster3-worker2:~# systemctl restart kubelet

➜ root@cluster3-worker2:~# service kubelet status
XXX
</code></pre>
<p>We can ignore the errors and move into next step to generate the join command.</p>
<h6 id="add-cluster3-master2-to-cluster">Add cluster3-master2 to cluster</h6>
<p>First we log into the master1 and generate a new TLS bootstrap token, also printing out the join command:</p>
<pre><code class="language-shell">➜ ssh cluster3-master1

➜ root@cluster3-master1:~# kubeadm token create --print-join-command
kubeadm join 192.168.100.31:6443 --token leqq1l.1hlg4rw8mu7brv73 --discovery-token-ca-cert-hash sha256:2e2c3407a256fc768f0d8e70974a8e24d7b9976149a79bd08858c4d7aa2ff79a

➜ root@cluster3-master1:~# kubeadm token list
TOKEN                     TTL         EXPIRES                ...
mnkpfu.d2lpu8zypbyumr3i   23h         2020-05-01T22:43:45Z   ...
poa13f.hnrs6i6ifetwii75   &lt;forever&gt;   &lt;never&gt;                ...
</code></pre>
<p>We see the expiration of 23h for our token, we could adjust this by passing the ttl argument.</p>
<p>Next we connect again to worker2 and simply execute the join command:</p>
<pre><code class="language-shell">➜ ssh cluster3-worker2

➜ root@cluster3-worker2:~# kubeadm join 192.168.100.31:6443 --token leqq1l.1hlg4rw8mu7brv73 --discovery-token-3c9cf14535ebfac8a23a91132b75436b36df2c087aa99c433f79d531
[preflight] Running pre-flight checks
[preflight] Reading configuration from the cluster...
[preflight] FYI: You can look at this config file with 'kubectl -n kube-system get cm kubeadm-config -o yaml'
W0107 13:37:31.116994   37798 utils.go:69] The recommended value for &quot;resolvConf&quot; in &quot;KubeletConfiguration&quot; is: /run/systemd/resolve/resolv.conf; the provided value is: /run/systemd/resolve/resolv.conf
[kubelet-start] Writing kubelet configuration to file &quot;/var/lib/kubelet/config.yaml&quot;
[kubelet-start] Writing kubelet environment file with flags to file &quot;/var/lib/kubelet/kubeadm-flags.env&quot;
[kubelet-start] Starting the kubelet
[kubelet-start] Waiting for the kubelet to perform the TLS Bootstrap...

This node has joined the cluster:
* Certificate signing request was sent to apiserver and a response was received.
* The Kubelet was informed of the new secure connection details.

Run 'kubectl get nodes' on the control-plane to see this node join the cluster.


➜ root@cluster3-worker2:~# service kubelet status
● kubelet.service - kubelet: The Kubernetes Node Agent
     Loaded: loaded (/lib/systemd/system/kubelet.service; enabled; vendor preset: enabled)
    Drop-In: /etc/systemd/system/kubelet.service.d
             └─10-kubeadm.conf
     Active: active (running) since Wed 2021-09-15 17:12:32 UTC; 42s ago
       Docs: https://kubernetes.io/docs/home/
   Main PID: 24771 (kubelet)
      Tasks: 13 (limit: 467)
     Memory: 68.0M
     CGroup: /system.slice/kubelet.service
             └─24771 /usr/bin/kubelet --bootstrap-kubeconfig=/etc/kubernetes/bootstrap-kubelet.conf --kubeconfig=/etc/kuber&gt;
</code></pre>
<p>If you have troubles with <code>kubeadm join</code> you might need to run <code>kubeadm reset</code>.</p>
<p>This looks great though for us. Finally we head back to the main terminal and check the node status:</p>
<pre><code class="language-shell">➜ k get node
NAME               STATUS    ROLES                   AGE    VERSION
cluster3-master1   Ready      control-plane,master   24h   v1.23.1
cluster3-worker1   Ready      &lt;none&gt;                 24h   v1.23.1
cluster3-worker2   NotReady   &lt;none&gt;                 32s   v1.23.1
</code></pre>
<p>Give it a bit of time till the node is ready.</p>
<pre><code class="language-shell">➜ k get node
NAME               STATUS   ROLES                  AGE    VERSION
cluster3-master1   Ready    control-plane,master   24h    v1.23.1
cluster3-worker1   Ready    &lt;none&gt;                 24h    v1.23.1
cluster3-worker2   Ready    &lt;none&gt;                 107s   v1.23.1
</code></pre>
<p>We see <code>cluster3-worker2</code> is now available and up to date.</p>
<h2 id="question-21--create-a-static-pod-and-service">Question 21 | Create a Static Pod and Service</h2>
<p><em>Task weight: 2%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c3-CCC</code></p>
<p>Create a <code>Static Pod</code> named <code>my-static-pod</code> in <em>Namespace</em> <code>default</code> on cluster3-master1. It should be of image <code>nginx:1.16-alpine</code> and have resource requests for <code>10m</code> CPU and <code>20Mi</code> memory.</p>
<p>Then create a NodePort <em>Service</em> named <code>static-pod-service</code> which exposes that static <em>Pod</em> on port 80 and check if it has <em>Endpoints</em> and if its reachable through the <code>cluster3-master1</code> internal IP address. You can connect to the internal node IPs from your main terminal.</p>
<h5 id="answer-20">Answer:</h5>
<pre><code class="language-shell">➜ ssh cluster3-master1

➜ root@cluster1-master1:~# cd /etc/kubernetes/manifests/

➜ root@cluster1-master1:~# kubectl run my-static-pod \
    --image=nginx:1.16-alpine \
    -o yaml --dry-run=client &gt; my-static-pod.yaml
</code></pre>
<p>Then edit the <code>my-static-pod.yaml</code> to add the requested resource requests:</p>
<pre><code class="language-yaml"># /etc/kubernetes/manifests/my-static-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    run: my-static-pod
  name: my-static-pod
spec:
  containers:
  - image: nginx:1.16-alpine
    name: my-static-pod
    resources:
      requests:
        cpu: 10m
        memory: 20Mi
  dnsPolicy: ClusterFirst
  restartPolicy: Always
status: {}
</code></pre>
<p>And make sure its running:</p>
<pre><code class="language-shell">➜ k get pod -A | grep my-static
NAMESPACE     NAME                             READY   STATUS   ...   AGE
default       my-static-pod-cluster3-master1   1/1     Running  ...   22s
</code></pre>
<p>Now we expose that static <em>Pod</em>:</p>
<pre><code class="language-shell">k expose pod my-static-pod-cluster3-master1 \
  --name static-pod-service \
  --type=NodePort \
  --port 80
</code></pre>
<p>This would generate a <em>Service</em> like:</p>
<pre><code class="language-yaml"># kubectl expose pod my-static-pod-cluster3-master1 --name static-pod-service --type=NodePort --port 80
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    run: my-static-pod
  name: static-pod-service
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    run: my-static-pod
  type: NodePort
status:
  loadBalancer: {}
</code></pre>
<p>Then run and test:</p>
<pre><code class="language-shell">➜ k get svc,ep -l run=my-static-pod
NAME                         TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE
service/static-pod-service   NodePort   10.99.168.252   &lt;none&gt;        80:30352/TCP   30s

NAME                           ENDPOINTS      AGE
endpoints/static-pod-service   10.32.0.4:80   30s
</code></pre>
<p>Looking good.</p>
<h2 id="question-22--check-how-long-certificates-are-valid">Question 22 | Check how long certificates are valid</h2>
<p><em>Task weight: 2%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c2-AC</code></p>
<p>Check how long the kube-apiserver server certificate is valid on <code>cluster2-master1</code>. Do this with openssl or cfssl. Write the exipiration date into <code>/opt/course/22/expiration</code>.</p>
<p>Also run the correct <code>kubeadm</code> command to list the expiration dates and confirm both methods show the same date.</p>
<p>Write the correct <code>kubeadm</code> command that would renew the apiserver server certificate into <code>/opt/course/22/kubeadm-renew-certs.sh</code>.</p>
<h5 id="answer-21">Answer:</h5>
<p>First let&rsquo;s find that certificate:</p>
<pre><code class="language-shell">➜ ssh cluster2-master1

➜ root@cluster2-master1:~# find /etc/kubernetes/pki | grep apiserver
/etc/kubernetes/pki/apiserver.crt
/etc/kubernetes/pki/apiserver-etcd-client.crt
/etc/kubernetes/pki/apiserver-etcd-client.key
/etc/kubernetes/pki/apiserver-kubelet-client.crt
/etc/kubernetes/pki/apiserver.key
/etc/kubernetes/pki/apiserver-kubelet-client.key
</code></pre>
<p>Next we use openssl to find out the expiration date:</p>
<pre><code class="language-shell">➜ root@cluster2-master1:~# openssl x509  -noout -text -in /etc/kubernetes/pki/apiserver.crt | grep Validity -A2
        Validity
            Not Before: Jan 14 18:18:15 2021 GMT
            Not After : Jan 14 18:49:40 2022 GMT
</code></pre>
<p>There we have it, so we write it in the required location on our main terminal:</p>
<pre><code class="language-shell"># /opt/course/22/expiration
Jan 14 18:49:40 2022 GMT
</code></pre>
<p>And we use the feature from kubeadm to get the expiration too:</p>
<pre><code class="language-shell">➜ root@cluster2-master1:~# kubeadm certs check-expiration | grep apiserver
apiserver                Jan 14, 2022 18:49 UTC   363d        ca               no      
apiserver-etcd-client    Jan 14, 2022 18:49 UTC   363d        etcd-ca          no      
apiserver-kubelet-client Jan 14, 2022 18:49 UTC   363d        ca               no 
</code></pre>
<p>Looking good. And finally we write the command that would renew all certificates into the requested location:</p>
<pre><code class="language-shell"># /opt/course/22/kubeadm-renew-certs.sh
kubeadm certs renew apiserver
</code></pre>
<h2 id="question-23--kubelet-clientserver-cert-info">Question 23 | Kubelet client/server cert info</h2>
<p><em>Task weight: 2%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c2-AC</code></p>
<p>Node cluster2-worker1 has been added to the cluster using <code>kubeadm</code> and TLS bootstrapping.</p>
<p>Find the &ldquo;Issuer&rdquo; and &ldquo;Extended Key Usage&rdquo; values of the cluster2-worker1:</p>
<ol>
<li>kubelet <strong>client</strong> certificate, the one used for outgoing connections to the kube-apiserver.</li>
<li>kubelet <strong>server</strong> certificate, the one used for incoming connections from the kube-apiserver.</li>
</ol>
<p>Write the information into file <code>/opt/course/23/certificate-info.txt</code>.</p>
<p>Compare the &ldquo;Issuer&rdquo; and &ldquo;Extended Key Usage&rdquo; fields of both certificates and make sense of these.</p>
<h5 id="answer-22">Answer:</h5>
<p>To find the correct kubelet certificate directory, we can look for the default value of the <code>--cert-dir</code> parameter for the kubelet. For this search for &ldquo;kubelet&rdquo; in the Kubernetes docs which will lead to: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet</a>. We can check if another certificate directory has been configured using <code>ps aux</code> or in <code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code>.</p>
<p>First we check the kubelet client certificate:</p>
<pre><code class="language-shell">➜ ssh cluster2-worker1

➜ root@cluster2-worker1:~# openssl x509  -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem | grep Issuer
        Issuer: CN = kubernetes
        
➜ root@cluster2-worker1:~# openssl x509  -noout -text -in /var/lib/kubelet/pki/kubelet-client-current.pem | grep &quot;Extended Key Usage&quot; -A1
            X509v3 Extended Key Usage: 
                TLS Web Client Authentication
</code></pre>
<p>Next we check the kubelet server certificate:</p>
<pre><code class="language-shell">➜ root@cluster2-worker1:~# openssl x509  -noout -text -in /var/lib/kubelet/pki/kubelet.crt | grep Issuer
          Issuer: CN = cluster2-worker1-ca@1588186506

➜ root@cluster2-worker1:~# openssl x509  -noout -text -in /var/lib/kubelet/pki/kubelet.crt | grep &quot;Extended Key Usage&quot; -A1
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication
</code></pre>
<p>We see that the server certificate was generated on the worker node itself and the client certificate was issued by the Kubernetes api. The &ldquo;Extended Key Usage&rdquo; also shows if its for client or server authentication.</p>
<p>More about this: <a href="https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping">https://kubernetes.io/docs/reference/command-line-tools-reference/kubelet-tls-bootstrapping</a></p>
<h2 id="question-24--networkpolicy">Question 24 | NetworkPolicy</h2>
<p><em>Task weight: 9%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c1-H</code></p>
<p>There was a security incident where an intruder was able to access the whole cluster from a single hacked backend <em>Pod</em>.</p>
<p>To prevent this create a <em>NetworkPolicy</em> called <code>np-backend</code> in <em>Namespace</em> <code>project-snake</code>. It should allow the <code>backend-*</code> <em>Pods</em> only to:</p>
<ul>
<li>connect to <code>db1-*</code> <em>Pods</em> on port 1111</li>
<li>connect to <code>db2-*</code> <em>Pods</em> on port 2222</li>
</ul>
<p>Use the <code>app</code> label of <em>Pods</em> in your policy.</p>
<p>After implementation, connections from <code>backend-*</code> <em>Pods</em> to <code>vault-*</code> <em>Pods</em> on port 3333 should for example no longer work.</p>
<h5 id="answer-23">Answer:</h5>
<p>First we look at the existing <em>Pods</em> and their labels:</p>
<pre><code class="language-shell">➜ k -n project-snake get pod
NAME        READY   STATUS    RESTARTS   AGE
backend-0   1/1     Running   0          8s
db1-0       1/1     Running   0          8s
db2-0       1/1     Running   0          10s
vault-0     1/1     Running   0          10s

➜ k -n project-snake get pod -L app
NAME        READY   STATUS    RESTARTS   AGE     APP
backend-0   1/1     Running   0          3m15s   backend
db1-0       1/1     Running   0          3m15s   db1
db2-0       1/1     Running   0          3m17s   db2
vault-0     1/1     Running   0          3m17s   vault
</code></pre>
<p>We test the current connection situation and see nothing is restricted:</p>
<pre><code class="language-shell">➜ k -n project-snake get pod -o wide
NAME        READY   STATUS    RESTARTS   AGE     IP          ...
backend-0   1/1     Running   0          4m14s   10.44.0.24  ...
db1-0       1/1     Running   0          4m14s   10.44.0.25  ...
db2-0       1/1     Running   0          4m16s   10.44.0.23  ...
vault-0     1/1     Running   0          4m16s   10.44.0.22  ...

➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.25:1111
database one

➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.23:2222
database two

➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.22:3333
vault secret storage
</code></pre>
<p>Now we create the <em>NP</em> by copying and chaning an example from the k8s docs:</p>
<pre><code class="language-yaml">vim 24_np.yaml
# 24_np.yaml
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: np-backend
  namespace: project-snake
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
    - Egress                    # policy is only about Egress
  egress:
    -                           # first rule
      to:                           # first condition &quot;to&quot;
      - podSelector:
          matchLabels:
            app: db1
      ports:                        # second condition &quot;port&quot;
      - protocol: TCP
        port: 1111
    -                           # second rule
      to:                           # first condition &quot;to&quot;
      - podSelector:
          matchLabels:
            app: db2
      ports:                        # second condition &quot;port&quot;
      - protocol: TCP
        port: 2222
</code></pre>
<p>The <em>NP</em> above has two rules with two conditions each, it can be read as:</p>
<pre><code class="language-shell">allow outgoing traffic if:
  (destination pod has label app=db1 AND port is 1111)
  OR
  (destination pod has label app=db2 AND port is 2222)
</code></pre>
<h6 id="wrong-example">Wrong example</h6>
<p>Now let&rsquo;s shortly look at a wrong example:</p>
<pre><code># WRONG
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: np-backend
  namespace: project-snake
spec:
  podSelector:
    matchLabels:
      app: backend
  policyTypes:
    - Egress
  egress:
    -                           # first rule
      to:                           # first condition &quot;to&quot;
      - podSelector:                    # first &quot;to&quot; possibility
          matchLabels:
            app: db1
      - podSelector:                    # second &quot;to&quot; possibility
          matchLabels:
            app: db2
      ports:                        # second condition &quot;ports&quot;
      - protocol: TCP                   # first &quot;ports&quot; possibility
        port: 1111
      - protocol: TCP                   # second &quot;ports&quot; possibility
        port: 2222
</code></pre>
<p>The <em>NP</em> above has one rule with two conditions and two condition-entries each, it can be read as:</p>
<pre><code class="language-shell">allow outgoing traffic if:
  (destination pod has label app=db1 OR destination pod has label app=db2)
  AND
  (destination port is 1111 OR destination port is 2222)
</code></pre>
<p>Using this <em>NP</em> it would still be possible for <code>backend-*</code> <em>Pods</em> to connect to <code>db2-*</code> <em>Pods</em> on port 1111 for example which should be forbidden.</p>
<h6 id="create-networkpolicy">Create NetworkPolicy</h6>
<p>We create the correct <em>NP</em>:</p>
<pre><code class="language-shell">k -f 24_np.yaml create
</code></pre>
<p>And test again:</p>
<pre><code class="language-shell">➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.25:1111
database one

➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.23:2222
database two

➜ k -n project-snake exec backend-0 -- curl -s 10.44.0.22:3333
^C
</code></pre>
<p>Also helpful to use <code>kubectl describe</code> on the <em>NP</em> to see how k8s has interpreted the policy.</p>
<p>Great, looking more secure. Task done.</p>
<h2 id="question-25--etcd-snapshot-save-and-restore">Question 25 | Etcd Snapshot Save and Restore</h2>
<p><em>Task weight: 8%</em></p>
<p>Use context: <code>kubectl config use-context k8s-c3-CCC</code></p>
<p>Make a backup of etcd running on cluster3-master1 and save it on the master node at <code>/tmp/etcd-backup.db</code>.</p>
<p>Then create a <em>Pod</em> of your kind in the cluster.</p>
<p>Finally restore the backup, confirm the cluster is still working and that the created <em>Pod</em> is no longer with us.</p>
<h5 id="answer-24">Answer:</h5>
<h6 id="etcd-backup">Etcd Backup</h6>
<p>First we log into the master and try to create a snapshop of etcd:</p>
<pre><code class="language-shell">➜ ssh cluster3-master1

➜ root@cluster3-master1:~# ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-backup.db
Error:  rpc error: code = Unavailable desc = transport is closing
</code></pre>
<p>But it fails because we need to authenticate ourselves. For the necessary information we can check the etc manifest:</p>
<pre><code class="language-shell">➜ root@cluster3-master1:~# vim /etc/kubernetes/manifests/etcd.yaml
</code></pre>
<p>We only check the <code>etcd.yaml</code> for necessary information we don&rsquo;t change it.</p>
<pre><code class="language-yaml"># /etc/kubernetes/manifests/etcd.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    component: etcd
    tier: control-plane
  name: etcd
  namespace: kube-system
spec:
  containers:
  - command:
    - etcd
    - --advertise-client-urls=https://192.168.100.31:2379
    - --cert-file=/etc/kubernetes/pki/etcd/server.crt                           # use
    - --client-cert-auth=true
    - --data-dir=/var/lib/etcd
    - --initial-advertise-peer-urls=https://192.168.100.31:2380
    - --initial-cluster=cluster3-master1=https://192.168.100.31:2380
    - --key-file=/etc/kubernetes/pki/etcd/server.key                            # use
    - --listen-client-urls=https://127.0.0.1:2379,https://192.168.100.31:2379   # use
    - --listen-metrics-urls=http://127.0.0.1:2381
    - --listen-peer-urls=https://192.168.100.31:2380
    - --name=cluster3-master1
    - --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt
    - --peer-client-cert-auth=true
    - --peer-key-file=/etc/kubernetes/pki/etcd/peer.key
    - --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt                    # use
    - --snapshot-count=10000
    - --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt
    image: k8s.gcr.io/etcd:3.3.15-0
    imagePullPolicy: IfNotPresent
    livenessProbe:
      failureThreshold: 8
      httpGet:
        host: 127.0.0.1
        path: /health
        port: 2381
        scheme: HTTP
      initialDelaySeconds: 15
      timeoutSeconds: 15
    name: etcd
    resources: {}
    volumeMounts:
    - mountPath: /var/lib/etcd
      name: etcd-data
    - mountPath: /etc/kubernetes/pki/etcd
      name: etcd-certs
  hostNetwork: true
  priorityClassName: system-cluster-critical
  volumes:
  - hostPath:
      path: /etc/kubernetes/pki/etcd
      type: DirectoryOrCreate
    name: etcd-certs
  - hostPath:
      path: /var/lib/etcd                                                     # important
      type: DirectoryOrCreate
    name: etcd-data
status: {}
</code></pre>
<p>But we also know that the api-server is connecting to etcd, so we can check how its manifest is configured:</p>
<pre><code class="language-shell">➜ root@cluster3-master1:~# cat /etc/kubernetes/manifests/kube-apiserver.yaml | grep etcd
    - --etcd-cafile=/etc/kubernetes/pki/etcd/ca.crt
    - --etcd-certfile=/etc/kubernetes/pki/apiserver-etcd-client.crt
    - --etcd-keyfile=/etc/kubernetes/pki/apiserver-etcd-client.key
    - --etcd-servers=https://127.0.0.1:2379
</code></pre>
<p>We use the authentication information and pass it to etcdctl:</p>
<pre><code class="language-shell">➜ root@cluster3-master1:~# ETCDCTL_API=3 etcdctl snapshot save /tmp/etcd-backup.db \
--cacert /etc/kubernetes/pki/etcd/ca.crt \
--cert /etc/kubernetes/pki/etcd/server.crt \
--key /etc/kubernetes/pki/etcd/server.key

Snapshot saved at /tmp/etcd-backup.db
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> Dont use <code>snapshot status</code> because it can alter the snapshot file and render it invalid</p>
</blockquote>
<h6 id="etcd-restore">Etcd restore</h6>
<p>Now create a <em>Pod</em> in the cluster and wait for it to be running:</p>
<pre><code class="language-shell">➜ root@cluster3-master1:~# kubectl run test --image=nginx
pod/test created

➜ root@cluster3-master1:~# kubectl get pod -l run=test -w
NAME   READY   STATUS    RESTARTS   AGE
test   1/1     Running   0          60s
</code></pre>
<blockquote>
<p><strong>NOTE:</strong> If you didn&rsquo;t solve questions 18 or 20 and cluster3 doesn&rsquo;t have a ready worker node then the created pod might stay in a Pending state. This is still ok for this task.</p>
</blockquote>
<p>Next we stop all controlplane components:</p>
<pre><code class="language-shell">root@cluster3-master1:~# cd /etc/kubernetes/manifests/

root@cluster3-master1:/etc/kubernetes/manifests# mv * ..

root@cluster3-master1:/etc/kubernetes/manifests# watch crictl ps
</code></pre>
<p>Now we restore the snapshot into a specific directory:</p>
<pre><code class="language-shell">➜ root@cluster3-master1:~# ETCDCTL_API=3 etcdctl snapshot restore /tmp/etcd-backup.db \
--data-dir /var/lib/etcd-backup \
--cacert /etc/kubernetes/pki/etcd/ca.crt \
--cert /etc/kubernetes/pki/etcd/server.crt \
--key /etc/kubernetes/pki/etcd/server.key

2020-09-04 16:50:19.650804 I | mvcc: restore compact to 9935
2020-09-04 16:50:19.659095 I | etcdserver/membership: added member 8e9e05c52164694d [http://localhost:2380] to cluster cdf818194e3a8c32
</code></pre>
<p>We could specify another host to make the backup from by using <code>etcdctl --endpoints http://IP</code>, but here we just use the default value which is: <code>http://127.0.0.1:2379,http://127.0.0.1:4001</code>.</p>
<p>The restored files are located at the new folder <code>/var/lib/etcd-backup</code>, now we have to tell etcd to use that directory:</p>
<pre><code class="language-yaml">➜ root@cluster3-master1:~# vim /etc/kubernetes/etcd.yaml
# /etc/kubernetes/etcd.yaml
apiVersion: v1
kind: Pod
metadata:
  creationTimestamp: null
  labels:
    component: etcd
    tier: control-plane
  name: etcd
  namespace: kube-system
spec:
...
    - mountPath: /etc/kubernetes/pki/etcd
      name: etcd-certs
  hostNetwork: true
  priorityClassName: system-cluster-critical
  volumes:
  - hostPath:
      path: /etc/kubernetes/pki/etcd
      type: DirectoryOrCreate
    name: etcd-certs
  - hostPath:
      path: /var/lib/etcd-backup                # change
      type: DirectoryOrCreate
    name: etcd-data
status: {}
</code></pre>
<p>Now we move all controlplane yaml again into the manifest directory. Give it some time (up to several minutes) for etcd to restart and for the api-server to be reachable again:</p>
<pre><code class="language-shell">root@cluster3-master1:/etc/kubernetes/manifests# mv ../*.yaml .

root@cluster3-master1:/etc/kubernetes/manifests# watch crictl ps
</code></pre>
<p>Then we check again for the <em>Pod</em>:</p>
<pre><code class="language-shell">➜ root@cluster3-master1:~# kubectl get pod -l run=test
No resources found in default namespace.
</code></pre>
<p>Awesome, backup and restore worked as our pod is gone.</p>
<h1 id="cka-tips-kubernetes-123">CKA Tips Kubernetes 1.23</h1>
<p>In this section we&rsquo;ll provide some tips on how to handle the CKA exam and browser terminal.</p>
<h2 id="knowledge">Knowledge</h2>
<p>Study all topics as proposed in the curriculum till you feel comfortable with all.</p>
<p><strong>Resources</strong></p>
<p>The majority of tasks in the CKA will also be around creating Kubernetes resources, like its tested in the CKAD. So we suggest to do:</p>
<ul>
<li>Maybe 2–3 times <a href="https://github.com/dgkanatsios/CKAD-exercises">https://github.com/dgkanatsios/CKAD-exercises</a></li>
<li>The <a href="https://codeburst.io/kubernetes-ckad-weekly-challenges-overview-and-tips-7282b36a2681">CKAD series with scenarios</a> on Medium</li>
<li>The <a href="https://medium.com/@wuestkamp/kubernetes-cka-example-questions-practical-challenge-86318d85b4d?source=friends_link&amp;sk=cb63eb0edd1210851f01df24b2142db2">CKA series with scenarios</a> on Medium</li>
<li>Imagine and create your own scenarios to solve</li>
<li>Know advanced scheduling: <a href="https://kubernetes.io/docs/concepts/scheduling/kube-scheduler">https://kubernetes.io/docs/concepts/scheduling/kube-scheduler</a></li>
</ul>
<p><strong>Components</strong></p>
<ul>
<li>The other part is understanding Kubernetes components and being able to fix and investigate clusters. Understand this: <a href="https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster">https://kubernetes.io/docs/tasks/debug-application-cluster/debug-cluster</a></li>
<li>When you have to fix a component (like kubelet) in one cluster, just check how its setup on another node in the same or even another cluster. You can copy config files over etc</li>
<li>If you like you can look at <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">Kubernetes The Hard Way</a> once. But it&rsquo;s NOT necessary to do, the CKA is not that complex. But KTHW helps understanding the concepts</li>
<li>You should install your own cluster using kubeadm (one master, one worker) in a VM or using a cloud provider and investigate the components</li>
<li>Know how to use kubeadm to for example add nodes to a cluster</li>
<li>Know how to create an Ingress resources</li>
<li>Know how to snapshot/restore ETCD from another machine</li>
</ul>
<p><strong>General</strong></p>
<p>Do 1 or 2 test session with this CKA Simulator. Understand the solutions and maybe try out other ways to achieve the same thing.</p>
<p>Setup your aliases, be fast and breath <code>kubectl</code></p>
<h2 id="cka-preparation">CKA Preparation</h2>
<p><strong>Read the Curriculum</strong></p>
<p><a href="https://github.com/cncf/curriculum">https://github.com/cncf/curriculum</a></p>
<p><strong>Read the Handbook</strong></p>
<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/lf-candidate-handbook">https://docs.linuxfoundation.org/tc-docs/certification/lf-candidate-handbook</a></p>
<p><strong>Read the important tips</strong></p>
<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad">https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad</a></p>
<p><strong>Read the FAQ</strong></p>
<p><a href="https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad">https://docs.linuxfoundation.org/tc-docs/certification/faq-cka-ckad</a></p>
<h2 id="kubernetes-documentation">Kubernetes documentation</h2>
<p>Get familiar with the Kubernetes documentation and be able to use the search. You can have one browser tab open with one of the allowed links: <a href="https://kubernetes.io/docs">https://kubernetes.io/docs</a> <a href="https://github.com/kubernetes">https://github.com/kubernetes</a> <a href="https://kubernetes.io/blog">https://kubernetes.io/blog</a></p>
<blockquote>
<p>*<strong>NOTE:*</strong> You can have the other tab open as a separate window, this is why a big screen is handy</p>
</blockquote>
<h2 id="deprecated-commands">Deprecated commands</h2>
<p>Make sure to not depend on deprecated commands as they might stop working at any time. When you execute a deprecated <code>kubectl</code> command a message will be shown, so you know which ones to avoid.</p>
<p>With <code>kubectl</code> version 1.18+ things have changed. Like its no longer possible to use <code>kubectl run</code> to create Jobs, CronJobs or Deployments, only Pods still work. This makes things a bit more verbose when you for example need to create a Deployment with resource limits or multiple replicas.</p>
<p>What if we need to create a Deployment which has, for example, a resources section? We could use both <code>kubectl run</code> and <code>kubectl create</code>, then do some vim magic. <a href="https://medium.com/@wuestkamp/be-fast-with-kubectl-1-18-ckad-cka-31be00acc443?source=friends_link&amp;sk=a66ae3c7b7ee85cb9c43129e7cf406e6">Read more here</a>.</p>
<h2 id="the-test-environment--browser-terminal">The Test Environment / Browser Terminal</h2>
<p>You&rsquo;ll be provided with a browser terminal which uses Ubuntu 20. The standard shells included with a minimal install of Ubuntu 20 will be available, including bash.</p>
<p><strong>Laggin</strong></p>
<p>There could be some lagging, definitely make sure you are using a good internet connection because your webcam and screen are uploading all the time.</p>
<p><strong>Kubectl autocompletion and commands</strong></p>
<p>Autocompletion is configured by default, as well as the <code>k</code> alias <a href="https://docs.linuxfoundation.org/tc-docs/certification/tips-cka-and-ckad">source</a> and others:</p>
<p><code>kubectl</code> with <code>k</code> alias and Bash autocompletion</p>
<p><code>yq</code> and <code>jq</code>for YAML/JSON processing</p>
<p><code>tmux</code> for terminal multiplexing</p>
<p><code>curl</code> and <code>wget</code> for testing web services</p>
<p><code>man</code> and man pages for further documentation</p>
<p><strong>Copy &amp; Paste</strong></p>
<p>There could be issues copying text (like pod names) from the left task information into the terminal. Some suggested to &ldquo;hard&rdquo; hit or long hold <code>Cmd/Ctrl+C</code> a few times to take action. Apart from that copy and paste should just work like in normal terminals.</p>
<p><strong>Percentages and Score</strong></p>
<p>There are 15-20 questions in the exam and 100% of total percentage to reach. Each questions shows the % it gives if you solve it. Your results will be automatically checked according to the handbook. If you don&rsquo;t agree with the results you can request a review by contacting the Linux Foundation support.</p>
<p><strong>Notepad &amp; Skipping Questions</strong></p>
<p>You have access to a simple notepad in the browser which can be used for storing any kind of plain text. It makes sense to use this for saving skipped question numbers and their percentages. This way it&rsquo;s possible to move some questions to the end. It might make sense to skip 2% or 3% questions and go directly to higher ones.</p>
<p><strong>Contexts</strong></p>
<p>You&rsquo;ll receive access to various different clusters and resources in each. They provide you the exact command you need to run to connect to another cluster/context. But you should be comfortable working in different namespaces with <code>kubectl</code>.</p>
<h2 id="your-desktop">Your Desktop</h2>
<p>You are allowed to have multiple monitors connected and have to share every monitor with the proctor. Having one large screen definitely helps as you’re only allowed <strong>one</strong> application open (Chrome Browser) with two tabs, one terminal and one k8s docs.</p>
<blockquote>
<p>*<strong>NOTE:*</strong> You can have the other tab open as a separate window, this is why a big screen is handy</p>
</blockquote>
<p>The questions will be on the left (default maybe ~30% space), the terminal on the right. You can adjust the size of the split though to your needs in the real exam.</p>
<p>If you use a laptop you could work with lid closed, external mouse+keyboard+monitor attached. Make sure you also have a webcam+microphone working.</p>
<p>You could also have both monitors, laptop screen and external, active. You might be asked that your webcam points straight into your face. So using an external screen and your laptop webcam could not be accepted. Just keep that in mind.</p>
<p>You have to be able to move your webcam around in the beginning to show your whole room and desktop. Have a clean desk with only the necessary on it. You can have a glass/cup with water without anything printed on.</p>
<p>In the end you should feel very comfortable with your setup.</p>
<h2 id="browser-terminal-setup">Browser Terminal Setup</h2>
<p>It should be considered to spend ~1 minute in the beginning to setup your terminal. In the real exam the vast majority of questions will be done from the main terminal. For few you might need to ssh into another machine. Just be aware that configurations to your shell will not be transferred in this case.</p>
<h4 id="minimal-setup">Minimal Setup</h4>
<p><strong>Alias</strong></p>
<p>The alias <code>k</code> for <code>kubectl</code> will be configured together with autocompletion. In case not you can configure it using this <a href="https://kubernetes.io/docs/reference/kubectl/cheatsheet">link</a>.</p>
<p><strong>Vim</strong></p>
<p>Create the file <code>~/.vimrc</code> with the following content:</p>
<pre><code class="language-shell">set tabstop=2
set expandtab
set shiftwidth=2
</code></pre>
<p>The <code>expandtab</code> make sure to use spaces for tabs. Memorize these and just type them down. You can&rsquo;t have any written notes with commands on your desktop etc.</p>
<h4 id="optional-setup">Optional Setup</h4>
<p><strong>Fast dry-run output</strong></p>
<pre><code class="language-shell">export do=&quot;--dry-run=client -o yaml&quot;
</code></pre>
<p>This way you can just run <code>k run pod1 --image=nginx $do</code>. Short for &ldquo;dry output&rdquo;, but use whatever name you like.</p>
<p><strong>Fast pod delete</strong></p>
<pre><code class="language-shell">export now=&quot;--force --grace-period 0&quot;
</code></pre>
<p>This way you can run <code>k delete pod1 $now</code> and don&rsquo;t have to wait for ~30 seconds termination time.</p>
<p><strong>Persist bash settings</strong></p>
<p>You can store aliases and other setup in <code>~/.bashrc</code> if you&rsquo;re planning on using different shells or <code>tmux</code>.</p>
<h3 id="be-fast">Be fast</h3>
<p>Use the <code>history</code> command to reuse already entered commands or use even faster history search through <strong>Ctrl r</strong> .</p>
<p>If a command takes some time to execute, like sometimes <code>kubectl delete pod x</code>. You can put a task in the background using <strong>Ctrl z</strong> and pull it back into foreground running command <code>fg</code>.</p>
<p>You can delete <em>pods</em> fast with:</p>
<pre><code class="language-shell">k delete pod x --grace-period 0 --force

k delete pod x $now # if export from above is configured
</code></pre>
<h3 id="vim-1">Vim</h3>
<p>Be great with vim.</p>
<p><strong>Toggle vim line numbers</strong></p>
<p>When in <code>vim</code> you can press <strong>Esc</strong> and type <code>:set number</code> or <code>:set nonumber</code> followed by <strong>Enter</strong> to toggle line numbers. This can be useful when finding syntax errors based on line - but can be bad when wanting to mark&amp;copy by mouse. You can also just jump to a line number with <strong>Esc</strong> <code>:22</code> + <strong>Enter</strong>.</p>
<p><strong>Copy&amp;paste</strong></p>
<p>Get used to copy/paste/cut with vim:</p>
<pre><code class="language-shell">Mark lines: Esc+V (then arrow keys)
Copy marked lines: y
Cut marked lines: d
Past lines: p or P
</code></pre>
<p><strong>Indent multiple lines</strong></p>
<p>In case not defined in <code>.vimrc</code>, to indent multiple lines press <strong>Esc</strong> and type <code>:set shiftwidth=2</code>.</p>
<p>First mark multiple lines using <code>Shift v</code> and the up/down keys. Then to indent the marked lines press <code>&gt;</code> or <code>&lt;</code>. You can then press <code>.</code> to repeat the action.</p>
<h3 id="split-terminal-screen">Split terminal screen</h3>
<p>By default <code>tmux</code> is installed and can be used to split your one terminal into multiple. <strong>But</strong> just do this if you know your shit, because scrolling is different and copy&amp;pasting might be weird.</p>
<p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux">https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux</a></p>

</article>


      
        <div class="my-4">
    
    <a href="/tags/kubernetes/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 me-2 hover:text-eureka">#kubernetes</a>
    
</div>
      

      



      
        <div class="py-2">
  
    <div class="my-8 flex flex-col items-center md:flex-row">
      <a href="/authors/%E4%BA%91%E5%8E%9F%E7%94%9F%E9%A9%BF%E7%AB%99/" class="md:me-4 text-primary-text h-24 w-24">
        
        
          <i class="fas fa-user-circle fa-6x"></i>
        
      </a>
      <div class="mt-4 w-full md:mt-0 md:w-auto">
        <a
          href="/authors/%E4%BA%91%E5%8E%9F%E7%94%9F%E9%A9%BF%E7%AB%99/"
          class="mb-2 block border-b pb-1 text-lg font-bold"
        >
          <h3>云原生驿站</h3>
        </a>
        <span class="block pb-2"></span>
        
      </div>
    </div>
  
</div>

      

      
  <div
    class="-mx-2 mt-4 flex flex-col border-t px-2 pt-4 md:flex-row md:justify-between"
  >
    <div>
      
    </div>
    <div class="mt-4 md:mt-0 md:text-right">
      
        <span class="text-primary-text block font-bold">下一页</span>
        <a href="/posts/kvm-memory-balloon-control-technology/" class="block">KVM的内存气球控制技术</a>
      
    </div>
  </div>


      



    </div>
    
      <div class="col-span-2">
        
          
<div class="bg-secondary-bg prose max-w-none rounded p-6">
  <h3>系列文章</h3>
  
    
      <a href="/posts/cka-practice/" class="no-underline">CKA Simulator Kubernetes 1.23</a>
      <br />
    
  
</div>

        
        
      </div>
    

    
    
  </div>

  
    <script>
      document.addEventListener("DOMContentLoaded", () => {
        hljs.highlightAll();
      });
    </script>

          </div>
        </div>
      
    </main>
    <footer class="pl-scrollbar">
      <div class="mx-auto w-full max-w-screen-xl"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">云原生驿站</p>
</div></div>
    </footer>
  </body>
</html>
